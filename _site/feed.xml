<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-09-12T10:34:44+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">iOS 开发栈</title><subtitle>专注 iOS 开发的中文博客 | ObjC、Swift、Xcode、SwiftUI、CoreData、Runtime、Runloop、内存管理、多线程。</subtitle><entry><title type="html">全面了解 Objective-C 语言</title><link href="http://localhost:4000/ios/objective-c/" rel="alternate" type="text/html" title="全面了解 Objective-C 语言" /><published>2022-05-24T20:58:33+08:00</published><updated>2022-05-24T20:58:33+08:00</updated><id>http://localhost:4000/ios/Programming-with-Objective-C</id><content type="html" xml:base="http://localhost:4000/ios/objective-c/">&lt;h1 id=&quot;全面了解-objective-c-语言&quot;&gt;全面了解 Objective-C 语言&lt;/h1&gt;

&lt;p&gt;到了2022年大多数iOS应用开发都开始用Swift了，不过 Objective-C 仍然是无法完全避开的，尤其是对于一些稍有规模的应用来说，需要用到好多三方库，而有一些三方库并没有Swift版本的。所以掌握 Objective-C 对于iOS开发还是很有必要的。&lt;/p&gt;

&lt;p&gt;从基础开始全面了解一个技术的方方面面才能更好的掌握它，而最全面的资料就非官方文档莫属了。&lt;/p&gt;

&lt;p&gt;这篇文章就是根据苹果的官方文档&lt;a href=&quot;https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/Introduction/Introduction.html#:~:text=Objective%2DC%20is%20the%20primary,capabilities%20and%20a%20dynamic%20runtime.&quot;&gt;Programming with Objective-C&lt;/a&gt;写的，其中主要涉及了几个比较重要的知识点。&lt;/p&gt;

&lt;p&gt;如果你对下面这几个问题并不确定，强烈建议耐心读完这篇文章：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Objective-C 中的类也是对象&lt;/li&gt;
  &lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;objective-c-语言定义&quot;&gt;Objective-C 语言定义&lt;/h2&gt;

&lt;p&gt;Objective-C 是 C 语言的超集，除了拥有和 C 语言相似的控制流、基本类型和语法之外，增加了面向对象和动态运行时。&lt;/p&gt;

&lt;p&gt;有了这个定义，下面我们来看 Objective-C 的具体语法。&lt;/p&gt;

&lt;h2 id=&quot;定义类&quot;&gt;定义类&lt;/h2&gt;

&lt;h3 id=&quot;类和对象&quot;&gt;类和对象&lt;/h3&gt;

&lt;p&gt;和其他面向对象语言一样，Objc 中的&lt;strong&gt;对象用来包装数据和行为&lt;/strong&gt;。&lt;strong&gt;对象是类的实例&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;每个对象有自己的数据内容，但是它们同享类的行为（方法）。&lt;/p&gt;

&lt;p&gt;Objc 的类中有些是不可变的，如 NSString/NSArray等，它们有可变的版本，如 NSMutableString/NSMutableArray&lt;/p&gt;

&lt;h3 id=&quot;继承&quot;&gt;继承&lt;/h3&gt;

&lt;p&gt;如果一个（子）类继承自另一个（父）类那么子类得到父类所有的方法和属性，子类可以增加方法/属性或者重写父类的方法。&lt;/p&gt;

&lt;p&gt;Objc 提供了一个基类 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NSObject&lt;/code&gt;，当需要自定义类的时候至少继承自 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NSObject&lt;/code&gt;，尽量继承自更合适的子类或子类的子类。&lt;/p&gt;

&lt;p&gt;子类不仅会继承父类中所有的属性和方法，还会把整个继承链中所有类的属性和方法都继承过来。&lt;/p&gt;

&lt;h3 id=&quot;接口和实现&quot;&gt;接口和实现&lt;/h3&gt;

&lt;p&gt;接口是用来定义需要暴露给其他对象的属性和行为的，实现是具体的做法，需要隐藏起来。&lt;/p&gt;

&lt;p&gt;Objc 中接口和实现分为不同的文件，接口以 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.h&lt;/code&gt; 接口，实现以 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.m&lt;/code&gt; 结尾。&lt;/p&gt;

&lt;h4 id=&quot;接口&quot;&gt;接口&lt;/h4&gt;

&lt;p&gt;定义接口的语法：&lt;/p&gt;

&lt;div class=&quot;language-objc highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SimpleClass&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;NSObject&lt;/span&gt;
    
&lt;span class=&quot;k&quot;&gt;@end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SimpleClass&lt;/code&gt; 类的定义中没有提供任何的属性和行为，不过由于它继承自 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NSObject&lt;/code&gt; ，其他对象可以访问它继承过来的属性和方法。下面看一个复杂的接口定义：&lt;/p&gt;

&lt;div class=&quot;language-objc highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;XYZPerson&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;NSObject&lt;/span&gt;
    
&lt;span class=&quot;k&quot;&gt;@property&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nonatomic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;copy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;readonly&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NSString&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;@property&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nonatomic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;assign&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;age&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSString&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;say&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSString&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;word&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;volumn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CGFloat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;volumn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    
&lt;span class=&quot;k&quot;&gt;@end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;XYZPerson&lt;/code&gt;类继承自 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NSObject&lt;/code&gt; 并且它提供了自己的属性和方法。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@property&lt;/code&gt; 用来定义属性，属性可以是对象类型和基本类型的，对象类型的需要使用指针（*）表示，基本类型就和 C 语言的基本类型一样。&lt;/p&gt;

&lt;p&gt;属性可以指定修饰符。OC 包含很多修饰符，大体上可以分为线程相关、内存管理相关和访问相关。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;分类&lt;/th&gt;
      &lt;th&gt;举例&lt;/th&gt;
      &lt;th&gt;说明&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;线程相关&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nonatomic&lt;/code&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;atomic&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;atomic&lt;/code&gt; - 原子性&lt;br /&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nonatomic&lt;/code&gt; - 非原子性&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;内存管理相关&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;copy&lt;/code&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;strong&lt;/code&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;assign&lt;/code&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;weak&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;copy&lt;/code&gt; - 复制&lt;br /&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;strong&lt;/code&gt; - 强引用&lt;br /&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;weak&lt;/code&gt; - 弱引用&lt;br /&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;assign&lt;/code&gt; - 基本数据类型&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;访问相关&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;readonly&lt;/code&gt;  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;readwrite&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;readonly&lt;/code&gt; - 只读，不能修改&lt;br /&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;readwrite&lt;/code&gt; - 可读可写，默认&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;OC 中的方法可以定义比较特性独行，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;XYZPerson&lt;/code&gt; 中定义了两个方法&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;write&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;say:valumn&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;方法以&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-&lt;/code&gt;开头，后面是用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;()&lt;/code&gt;包围的返回值，再是方法签名。可以有参数也可以没有参数，有参数的话使用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;:&lt;/code&gt;分隔，多个参数之间用空格分隔。方法名通常以小写字母开头并且遵守驼峰命名法，如：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;thisIsMethod&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&quot;实现&quot;&gt;实现&lt;/h4&gt;

&lt;p&gt;类实现的语法：&lt;/p&gt;

&lt;div class=&quot;language-objc highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#import &quot;XYZPerson.h&quot;
&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;@implementation&lt;/span&gt;
    
&lt;span class=&quot;err&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;write&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// something&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSString&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;say&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSString&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;word&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;volumn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CGFloat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;volumn&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// something&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;internalMethod&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// something&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    
&lt;span class=&quot;k&quot;&gt;@end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;实现文件中需要导入接口文件:&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;#import &quot;XYZPerson.h&quot;&lt;/code&gt; 实现内容在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@implementation&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@end&lt;/code&gt; 之间，其中&lt;strong&gt;必须包含所有接口中定义的方法和可选任意数量私有方法&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&quot;类本身也是对象&quot;&gt;类本身也是对象&lt;/h3&gt;

&lt;p&gt;OC 中的类本身也是对象，叫做&lt;strong&gt;类对象&lt;/strong&gt;。类对象不能定义属性，但是可以定义方法（类方法）接受消息。比如 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NSString&lt;/code&gt; 类对象中就包括很多类方法：&lt;/p&gt;

&lt;div class=&quot;language-objc highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;stringWithString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSString&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;aString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;类方法以 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;+&lt;/code&gt; 开头，返回值和参数和对象方法相同，类方法使用类名调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[NSString string]&lt;/code&gt;。类方法的实现和实力方法相同。&lt;/p&gt;

&lt;h2 id=&quot;对象&quot;&gt;对象&lt;/h2&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;本文章的内容大多数来自苹果的官方文档&lt;a href=&quot;https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/Introduction/Introduction.html#:~:text=Objective%2DC%20is%20the%20primary,capabilities%20and%20a%20dynamic%20runtime.&quot;&gt;Programming with Objective-C&lt;/a&gt;，建议通读。&lt;/p&gt;</content><author><name></name></author><category term="iOS" /><summary type="html">全面了解 Objective-C 语言</summary></entry><entry><title type="html">lldb 启动、添加断点、调试、终止</title><link href="http://localhost:4000/cs/lldb-tutorial/" rel="alternate" type="text/html" title="lldb 启动、添加断点、调试、终止" /><published>2022-03-28T03:42:43+08:00</published><updated>2022-03-28T03:42:43+08:00</updated><id>http://localhost:4000/cs/lldb-tutorial</id><content type="html" xml:base="http://localhost:4000/cs/lldb-tutorial/">&lt;p&gt;开发过程中基本都是在使用 IDE（Xcode）软件，IDE 里面集成了一整套开发工具链，虽然用起来非常方便，但是也让开发者丧失了接触具体工具的机会，而且 IDE 在很多的情况下都是阉割了工具的一些功能来达到方便的目的。因此直接学习某个工具可以让我们更好的了解整个开发过程，也可以更深入的利用工具的能力。&lt;/p&gt;

&lt;p&gt;本文就学习 LLDB 这个调试工具的用法，主要包括这几个部分：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;使用 LLDB 启动程序&lt;/li&gt;
  &lt;li&gt;打断点和分步调试&lt;/li&gt;
  &lt;li&gt;设置监测点（watch point)&lt;/li&gt;
&lt;/ol&gt;

&lt;!-- more --&gt;

&lt;iframe src=&quot;//player.bilibili.com/player.html?bvid=BV1Ar4y1p7J3&amp;amp;page=1&quot; style=&quot;width:100%;height: 400px&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot;&gt; &lt;/iframe&gt;

&lt;h1 id=&quot;启动程序&quot;&gt;启动程序&lt;/h1&gt;

&lt;p&gt;要想对一个程序进行调试就必须在 debug 模式下编译该程序，不同的编译工具命令也不同，下面是 gcc 和 clang 命令行：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;gcc(clang) -g 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;编译之后就可以使用 lldb 启动程序了：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;lldb  a.out
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这样就进入了 lldb 命令中，要运行程序可以使用：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(lldb) run
(lldb) r
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上面的第 2 行是第 1 行的快捷方式，下面还有类似用法不再进行说明。&lt;/p&gt;

&lt;h1 id=&quot;设置断点&quot;&gt;设置断点&lt;/h1&gt;

&lt;p&gt;设置断点的方式可以分为在源码的某一行加断点和根据符号（方法名）加断点。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 某行加断点
// # 表示行号
(lldb) breakpoint set -f lldb_sample.c -l #
(lldb) br s -f lldb_sample.c -l #
(lldb) b lldb_sample.c : #

// 给方法名加断点
(lldb) b [方法名]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;操作断点&quot;&gt;操作断点&lt;/h1&gt;

&lt;p&gt;列出所有已添加断点&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// br 是 breakpoint 的简写
(lldb) br list
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;删除断点&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 删除某个断点，# 可以从列出断点中查到
(lldb) br del #

// 删除所有断点
(lldb) br del
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;分步调试&quot;&gt;分步调试&lt;/h1&gt;

&lt;p&gt;跳过，是指跳过对其他方法的调用&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(lldb) next
(lldb) n
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;进入，进入被调用方法内部&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(lldb) step
(lldb) s
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;继续执行，直到下一个断点处或程序末尾&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(lldb) c
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;查看变量&quot;&gt;查看变量&lt;/h1&gt;

&lt;p&gt;打印变量内容&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(lldb) p varName
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;列出当前栈帧变量&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(lldb) frame variable
(lldb) fr v
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;切换栈帧&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(lldb) frame select #
(lldb) fr s
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;调用栈&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(lldb) bt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;使用监视断点&quot;&gt;使用监视断点&lt;/h1&gt;

&lt;p&gt;！只有在程序运行过程中才能使用监视断点。&lt;/p&gt;

&lt;p&gt;给全局变量设置监视断点&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(lldb) watchpoint set variable [some globalVariable]
(lldb) watchpoint set variable -w read | write | read_write [some globalVariable]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;给局部变量（自动变量）设置监视断点&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(lldb) b main
(lldb) w s v d.memberVar
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;终止调试&quot;&gt;终止调试&lt;/h1&gt;

&lt;p&gt;终止当前进行，强制结束程序执行，但是仍保留在 lldb 中&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(lldb) kill
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;退出 LLDB&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(lldb) quit (cmd-d)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name></name></author><category term="计算机基础" /><summary type="html">开发过程中基本都是在使用 IDE（Xcode）软件，IDE 里面集成了一整套开发工具链，虽然用起来非常方便，但是也让开发者丧失了接触具体工具的机会，而且 IDE 在很多的情况下都是阉割了工具的一些功能来达到方便的目的。因此直接学习某个工具可以让我们更好的了解整个开发过程，也可以更深入的利用工具的能力。</summary></entry><entry><title type="html">理解 Swift 的 ArraySlice</title><link href="http://localhost:4000/swift/swift-ArraySlice-in-Swift/" rel="alternate" type="text/html" title="理解 Swift 的 ArraySlice" /><published>2022-03-15T01:47:47+08:00</published><updated>2022-03-15T01:47:47+08:00</updated><id>http://localhost:4000/swift/swift-arrayslice-in-swift</id><content type="html" xml:base="http://localhost:4000/swift/swift-ArraySlice-in-Swift/">&lt;p&gt;今天的文章受到一个开发中遇到的问题启发，这个问题是在解决一个 iOS 项目界面问题的时候出现的。App 要展示包含在非常多数据中的数十条，并且需要支持水平滚动，这意味着我们需要根据用户的滚动不停更新界面。&lt;/p&gt;

&lt;p&gt;取决于用户想要展示的数据量，直接操作数据很快变得非常笨重并且在拷贝数据时要消耗非常多的资源。这时 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ArraySlice&lt;/code&gt; 就派上用场了。&lt;/p&gt;

&lt;!-- more --&gt;

&lt;blockquote&gt;
  &lt;p&gt;到公众号【iOS开发栈】学习更多Swift、SwiftUI、iOS开发相关内容。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;什么是-arrayslice&quot;&gt;什么是 ArraySlice&lt;/h1&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ArraySlice&lt;/code&gt; 是一个行为上和 array 非常相似的范型结构体。它支持 array 的几乎所有功能，因此对它的操作非常熟悉。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ArraySlice&lt;/code&gt; 的特色是它可以非常快速、高效地操作一个已经申请过内存的数组。就像这样：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../images/swift-arrayslice/slice.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如你所见，两个数组分别申请了自己的内存，并且分别保存了各自的元素，虽然这些元素可能是相同的（这个例子忽略了编译器优化，比如 Copy-On-Write，这个技术可以让我们利用同一块内存得到两个数组）。&lt;/p&gt;

&lt;p&gt;与此同时，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ArraySlice&lt;/code&gt;可以引用数组的一部分并把它当成自己的，这样做就高效的消除了复制值带来的开销。这种做法取决于你是通过引用数组来创建 slice 的。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ArraySlice&lt;/code&gt;也可以申请自己的内存，而不是通过引用数组的，但是这样做就失去了使用 slice 的意义。&lt;/p&gt;

&lt;p&gt;在我们深入代码之前，首先要意识到一个 ArraySlice 会增加对应数组的引用计数。正因为这样，你千万不能对 slice 持有时间过长，因为这样做会使对应 array 的内存无法释放。&lt;/p&gt;

&lt;h1 id=&quot;怎么使用-arrayslice&quot;&gt;怎么使用 ArraySlice&lt;/h1&gt;

&lt;p&gt;好问题！正如我在上面提到的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ArraySlice&lt;/code&gt; 拥有很多和 array 相同的方法，因此对 ArraySlice 的操作是非常熟悉的。&lt;/p&gt;

&lt;p&gt;我们从创建 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ArraySlice&lt;/code&gt; 开始，它会引用一个拥有 5 个元素数组中的中间 3 个元素。有好几个方法可以做到这个，但是我个人更倾向于这样做：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Swift&quot;&gt;var array = [1, 2, 3, 4, 5]
let slice = array[1...3]
print(slice)
// Prints [2, 3, 4]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在我们得到了一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ArraySlice&lt;/code&gt; 的实例。记住，它并没有创建对 2、3 和 4 的拷贝，它只是借用了 array 变量内存的一部分。&lt;/p&gt;

&lt;p&gt;让我们看一下我们是否可以使用新创建的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;slice&lt;/code&gt; 变量，从计算 slice 中所有元素的和开始：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Swift&quot;&gt;let sum = slice.reduce(0, +)
print(sum)
// Prints 9
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这没有什么问题。那获取 slice 的最大值呢？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Swift&quot;&gt;let max = slice.max()
print(max)
// Prints Optional(4)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这也没问题！&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.max()&lt;/code&gt; 方法返回一个可选值，array 中有可能不包含最大值。&lt;/p&gt;

&lt;p&gt;那怎么一个个的打印 slice 中的元素呢？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Swift&quot;&gt;for index in 0..&amp;lt; slice.count {
    print(slice[index])
}
// Fatal error: Index out of the bounds
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我去，这是怎么回事？&lt;/p&gt;

&lt;p&gt;这是一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ArraySlice&lt;/code&gt; 中非常有意思的细节。由于 slice 引用的是一个数组的内存空间，slice 的索引也使用了 array 的索引。因此 slice 的索引并不是从 0 到 2 的，而是从 1 到 3！&lt;/p&gt;

&lt;p&gt;那么怎么解决这个问题呢？&lt;/p&gt;

&lt;p&gt;我们使用一个适用于每一个可以被下标实例的技术，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ArraySlice&lt;/code&gt;类包含两个叫做 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.startIndex&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.endIndex&lt;/code&gt; 的属性，这两个属性用于访问 slice 开始和结束偏移量。这些与我们引用的 array 实例中元素的范围相匹配。像这样修改代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Swift&quot;&gt;for index in slice.startIndex ..&amp;lt; slice.endIndex {
    print(slice[index])
}
// Prints 2 3 4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;… 问题解决！另外需要注意的是，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.endIndex&lt;/code&gt;属性指的是紧跟 array 结尾的下一个元素，也就是说如果你包含这个元素那就会导致 Index Out Of Bounds 的错误。因此，在这里应该使用半开区间操作符（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;..&amp;lt;&lt;/code&gt;）。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;到公众号【iOS开发栈】学习更多Swift、SwiftUI、iOS开发相关内容。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;本文翻译自&lt;a href=&quot;https://medium.com/appcoda-tutorials/understanding-the-arrayslice-3b4957b9d965&quot;&gt;Understanding The ArraySlice in Swift&lt;/a&gt;&lt;/p&gt;</content><author><name></name></author><category term="Swift" /><summary type="html">今天的文章受到一个开发中遇到的问题启发，这个问题是在解决一个 iOS 项目界面问题的时候出现的。App 要展示包含在非常多数据中的数十条，并且需要支持水平滚动，这意味着我们需要根据用户的滚动不停更新界面。</summary></entry><entry><title type="html">一文打尽iOS八股文</title><link href="http://localhost:4000/ios/ios-ba-gu-wen/" rel="alternate" type="text/html" title="一文打尽iOS八股文" /><published>2022-03-03T00:36:31+08:00</published><updated>2022-03-03T00:36:31+08:00</updated><id>http://localhost:4000/ios/ios-ba-gu-wen</id><content type="html" xml:base="http://localhost:4000/ios/ios-ba-gu-wen/">&lt;p&gt;你喜欢”八股文“吗？&lt;/p&gt;

&lt;!-- more --&gt;

&lt;p&gt;有代有一位哲学家说过“编程=数据结构+算法“，每一个真正懂编程的都应该深刻理解这句话并点头同意。&lt;/p&gt;

&lt;p&gt;那么数据结构又是什么呢？数据结构就是操作内存的不同方式，不论是数组、链表、树还是图其实本质上就是两种 —— 连续的和不连续的。连续的优点是能够快速查找，但是在伸缩时就要麻烦点，不连续的容易伸缩，但是查找麻烦并且需要付出更多的空间作为代价。&lt;/p&gt;

&lt;p&gt;算法又是什么呢？算法就是操作各种数据结构的奇技淫巧，循环、递归、双指针等等无非都是遍历、访问、添加、删除数据结构时的方式。&lt;/p&gt;

&lt;p&gt;iOS 的八股文基本上就是指的各种语法的实现原理 —— 或者叫底层实现，这东西很重要，是因为这才是编程的本质，原因就是这里到处都是数据结构和算法，对这些不理解的话不只说明你不是一个合格的 iOS 程序员，甚至都不能说你是一个合格的程序员。&lt;/p&gt;

&lt;p&gt;但是八股文又没有那么重要，因为要掌握这些数据结构和算法不一定需要通过这些八股文的内容，你完全可以通过自己开发一个操作系统、数据库、编程语言来证明你对这些东西完全了如指掌。&lt;/p&gt;

&lt;p&gt;但是如果你没有其他方式证明自己是一个合格的程序员，那用人单位就只能通过这些八股文来证明你是一个合格的 iOS 程序员。&lt;/p&gt;

&lt;p&gt;那么怎么掌握这些八股文呢？看源码，相信你已经看到到很多这样的建议了，这个建议完全没有问题，就像当你发烧的时候被人跟你说你生病了一样正确。&lt;/p&gt;

&lt;p&gt;看源码是远远不够的，把看到的源码写篇博客远远不够。贴上一大段代码，添加上几行注释只能说明你看懂了这段逻辑和语法。&lt;/p&gt;

&lt;p&gt;要想真正掌握这些八股文一定要在看源码、读博客的基础上&lt;strong&gt;自己总结提炼&lt;/strong&gt;，每一个知识点的逻辑都要自己捋顺写下来说出来，自己评判一下有没有漏洞，是不是每一步都是闭合的自洽的。&lt;/p&gt;

&lt;p&gt;好了说了这么多，下面把我总结的 iOS 八股文贴上来，如果有不对的欢迎指出。我也鼓励你能够自己把这些内容消化成自己的逻辑。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;应用启动过程&quot;&gt;应用启动过程&lt;/h1&gt;

&lt;p&gt;主要包括三个部分：1. main函数前 2. main 函数 3. AppDelegate&lt;/p&gt;

&lt;h2 id=&quot;main-函数前做了哪些工作&quot;&gt;Main 函数前做了哪些工作&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;动态链接器加载应用程序&lt;/li&gt;
  &lt;li&gt;动态链接器加载用到的 dylib 动态库并完成 rebase 和 binding&lt;/li&gt;
  &lt;li&gt;Objc 运行时相关类的注册、分类的注册等&lt;/li&gt;
  &lt;li&gt;类的初始化，调用 load 方法&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;rebase-和-bind&quot;&gt;Rebase 和 Bind&lt;/h3&gt;

&lt;p&gt;ASLR(Address Space Layout Randomization) 地址空间布局随机化。动态库的位置不是固定的而是会从一个随机内存地址开始。&lt;/p&gt;

&lt;p&gt;Rebase 的作用就是为了消除 ASLR 产生的影响，给应用程序的内存地址设置正确的值，也就是相对地址 + 随机偏移量。&lt;/p&gt;

&lt;p&gt;Bind：由于 app 在运行时要依赖其他动态库中的内容，但是在打包时并不会直接把所依赖库一起打包，就需要在执行 app 时把动态库的函数定制进行绑定。&lt;/p&gt;

&lt;h2 id=&quot;优化应用启动时间&quot;&gt;优化应用启动时间&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;减少动态库的数量&lt;/li&gt;
  &lt;li&gt;减少类、分类数量，并把用不到的函数去掉&lt;/li&gt;
  &lt;li&gt;减少 load 方法以及里面的逻辑&lt;/li&gt;
  &lt;li&gt;减少 appDelegate 中 willFinish 和 didFinish 中的任务&lt;/li&gt;
  &lt;li&gt;调整启动过程中需要调用的函数位置，尽量放到同一个或两个内存页&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;分类的原理&quot;&gt;分类的原理&lt;/h1&gt;

&lt;p&gt;分类中的对象方法也是存放在类对象中的，同类中实现的方法在同一个地方，调用步骤两者也相同。&lt;/p&gt;

&lt;p&gt;分类的底层结构是一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;category_t&lt;/code&gt; 的结构体，里面包含了对象方法、类方法、协议和属性，但是里面&lt;em&gt;不包含实例变量。&lt;/em&gt;一个类的多个分类保存在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;category_list&lt;/code&gt; 中。&lt;/p&gt;

&lt;p&gt;在 runtime 中会把 category_t 中的方法、协议和属性拷贝到类对象的数组中，并且会放在原类方法的前面。&lt;/p&gt;

&lt;h1 id=&quot;load-initialize&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;load&lt;/code&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;initialize&lt;/code&gt;&lt;/h1&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt;load&lt;/th&gt;
      &lt;th&gt;initialize&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;调用时机&lt;/td&gt;
      &lt;td&gt;在程序启动就会调用，当装载类信息的时候就会调用&lt;/td&gt;
      &lt;td&gt;第一次使用类的时候&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;调用次序&lt;/td&gt;
      &lt;td&gt;优先调用类的load方法（先父类后子类），之后调用分类的load方法。&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;类和分类都是按照加载顺序调用。&lt;/td&gt;
      &lt;td&gt;分类重写initialize方法时只会调用最后加载的那个分类的方法。&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;先父类后子类。&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;调用次数&lt;/td&gt;
      &lt;td&gt;每个类/分类调用一次。&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;分类不会覆盖主类。&lt;/td&gt;
      &lt;td&gt;每一个类只会initialize一次。&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;分类实现后原类的不会调用&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;调用方式&lt;/td&gt;
      &lt;td&gt;直接拿到load方法的内存地址直接调用方法&lt;/td&gt;
      &lt;td&gt;通过消息发送机制调用的、&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&quot;关联对象原理&quot;&gt;关联对象原理&lt;/h1&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AssociationsManager&lt;/code&gt; 是一个顶级对象，维护了一个 spinlock_t 的锁和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AssociationsHashMap&lt;/code&gt; 单例对。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AssociationsHashMap&lt;/code&gt; 是一个无序的哈希表，维护了从对象地址到 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ObjectAssociationMap&lt;/code&gt; 的映射。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ObjectAssociationMap&lt;/code&gt; 维护了从 key(void * 类型) 到 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ObjcAssociation&lt;/code&gt; 的映射。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ObjectAssociation&lt;/code&gt;  是一个表示具体关联结构的类，主要包含 _policy _value 两个字段。&lt;/p&gt;

&lt;p&gt;每一个对象地址对应一个 ObjectAssociationMap 对象，而一个 ObjectAssociationMap 对象保存着这个对象的若干条关联记录。&lt;/p&gt;

&lt;h1 id=&quot;弱引用原理&quot;&gt;弱引用原理&lt;/h1&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SideTable&lt;/code&gt; 维护了一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;spinlock_t&lt;/code&gt; 的锁和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;weak_table_t&lt;/code&gt; 主要作用是在操作 weak_table_t 的时候加锁。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;weak_table_t&lt;/code&gt; 是一个全局弱引用表，主要保存了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;weak_entry_t&lt;/code&gt; 的数组以及哈希过程中用到的数据等。 通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;size_t begin = hash_pointer(referent) &amp;amp; weak_table-&amp;gt;mask;&lt;/code&gt; 找到对象的 weak_table_t。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;weak_entry_t&lt;/code&gt; 保存了被弱引用对象和弱引用对象地址数组。&lt;/p&gt;

&lt;p&gt;设置弱引用时会根据对象地址得到的哈希值找到 weak_table_t 的起始地址，之后遍历 weak_table_t 中的 entry，得到要添加到的位置，之后把新的弱引用放到这个位置。&lt;/p&gt;

&lt;p&gt;当弱引用对象销毁时，同样根据对象地址找到 weak_table_t，之后从 weak_entry_t 中的弱引用数组中找到要移除的弱引用对象将其置为 nil，当 weak_entry_t 中的弱引用数组被清空时把这个数组释放并将 weak_table_t 的 weak_entries 数组中对应的 weak_entry_t 内存清除。&lt;/p&gt;

&lt;h1 id=&quot;常见的内存泄漏有哪些怎么避免&quot;&gt;常见的内存泄漏有哪些？怎么避免？&lt;/h1&gt;

&lt;ol&gt;
  &lt;li&gt;NSTimer 循环引用。&lt;/li&gt;
  &lt;li&gt;自己封装一个类在这个类里进行计时。&lt;/li&gt;
  &lt;li&gt;使用 iOS10 之后可用的不带 target 参数的启动计时器方法&lt;/li&gt;
  &lt;li&gt;给 NSTimer 添加分类，分类中用带有 block 的方法将 target 设置成 NSTimer 本身&lt;/li&gt;
  &lt;li&gt;代理 delegate 用 strong 修饰（应该用 weak）&lt;/li&gt;
  &lt;li&gt;block 里面要用 __weak&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;自动释放池原理&quot;&gt;自动释放池原理&lt;/h1&gt;

&lt;p&gt;底层使用一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AutoreleasePoolPage&lt;/code&gt; 的双向链表实现的，整个程序运行过程中，可能会有多个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AutoreleasePoolPage&lt;/code&gt;对象。&lt;/p&gt;

&lt;p&gt;当向自动释放池中添加对象时，如果自动释放池不存在则创建一个 page，并将哨兵压栈。之后可以将需要自动释放的对象添加到 page 里面。&lt;/p&gt;

&lt;p&gt;如果满了就将哨兵压栈，并新建一页，并设置链表。&lt;/p&gt;

&lt;p&gt;释放过程是从最新的一页（hotpage）开始从后到前遍历当前页内的对象并挨个发送 release 消息。因为有哨兵的存在所以能够得到某一页的开始和结束。当一页没有任何对象了就销毁这一页。&lt;/p&gt;

&lt;h1 id=&quot;简述-runloop&quot;&gt;简述 Runloop&lt;/h1&gt;

&lt;p&gt;Runloop 本质上就是一个 while 死循环，有了这个循环就可以确保线程永远不会结束，这个循环通过操作系统底层的函数来进行休眠和唤起，以此来节省消耗。&lt;/p&gt;

&lt;p&gt;Runloop 主要的工作是接收并处理各种事件，包括创建和销毁自动释放池、处理点击时间、block回调、倒计时等等。&lt;/p&gt;

&lt;p&gt;一个 Runloop 包含多个 mode，一个 mode 又包含多个 source、timer、observer。&lt;/p&gt;

&lt;p&gt;线程和 Runloop 是一一对应的，它们的关系被保存在一个全局的 Dictionary 里。线程创建时并不会带有 Runloop，只有在第一次获取时才会创建。当线程结束时销毁 Runloop，除了主线程外，只能在线程内部获取对应的 Runloop。&lt;/p&gt;

&lt;h1 id=&quot;事件传递链&quot;&gt;事件传递链&lt;/h1&gt;

&lt;p&gt;AppDelegate → Window → ViewController → View → SubView → …&lt;/p&gt;

&lt;h1 id=&quot;响应链&quot;&gt;响应链&lt;/h1&gt;

&lt;p&gt;View → SuperView → … → ViewController → Window&lt;/p&gt;

&lt;h1 id=&quot;简述-runtime&quot;&gt;简述 Runtime&lt;/h1&gt;

&lt;p&gt;类C语言在编译后就确定了代码的执行过程，运行期只需要根据编译生成的二进制文件执行就可以了，而OC拥有一些动态特性，使它可以在运行期进行一些操作，比如说添加方法、交换方法等，而runtime就是用来实现这些动态特性的，此外Runtime还实现了消息转发机制。&lt;/p&gt;

&lt;p&gt;具体来说，OC的对象中都包含一个isa指针，根据这个指针可以找到当前实例对象的类对象，而类对象中包含了方法列表、属性列表、父类指针等成员，其中类对象也有一个isa指针，这个isa指针指向了元类对象，元类对象中包含了类方法列表和指向根元类的isa指针。&lt;/p&gt;

&lt;h2 id=&quot;runtime-查找方法的过程&quot;&gt;Runtime 查找方法的过程&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;到类的方法缓存中找&lt;/li&gt;
  &lt;li&gt;查找本类方法列表&lt;/li&gt;
  &lt;li&gt;沿着继承链向上找&lt;/li&gt;
  &lt;li&gt;进入转发流程
    &lt;ol&gt;
      &lt;li&gt;动态解析，是否为找不到的方法添加了方法 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;resolveInstanceMethod&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;有没有设置转发类来处理未实现的方法 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;forwardingTargetForSelector&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;有没有新添加的方法实现可以接收消息  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;forwardInvocation&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;消息转发的用途
        &lt;ol&gt;
          &lt;li&gt;JSPatch iOS 动态化更新&lt;/li&gt;
          &lt;li&gt;为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@dynamic&lt;/code&gt; 实现方法&lt;/li&gt;
          &lt;li&gt;实现多重代理&lt;/li&gt;
          &lt;li&gt;间接实现多继承&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;kvo-的实现原理&quot;&gt;KVO 的实现原理&lt;/h2&gt;

&lt;p&gt;当一个对象使用了KVO监听，iOS系统会修改这个对象的isa指针，改为指向一个全新的通过Runtime动态创建的子类，子类拥有自己的set方法实现，set方法实现内部会顺序调用&lt;strong&gt;willChangeValueForKey方法、原来的setter方法实现、didChangeValueForKey方法，而didChangeValueForKey方法内部又会调用监听器的observeValueForKeyPath:ofObject:change:context:监听方法。&lt;/strong&gt;&lt;/p&gt;

&lt;h1 id=&quot;mvvm&quot;&gt;MVVM&lt;/h1&gt;

&lt;h1 id=&quot;lru-算法&quot;&gt;LRU 算法&lt;/h1&gt;

&lt;p&gt;使用一个 hash 表和一个双向链表。&lt;/p&gt;

&lt;p&gt;hash 表存放 key 到 链表节点的映射，链表中每个节点包含 key 和 value，最近使用的在头节点，最后使用的在尾节点。&lt;/p&gt;

&lt;p&gt;当使用 key 获取数据的时候先根据 hashmap 判断 key 是否存在，如果存在再根据 key 找到节点，然后到链表的节点获取对应的 value，最后把这个节点提到链表的最前面。&lt;/p&gt;

&lt;p&gt;当添加 key，value 时，如果能从 hashmap 中获取到 key，说明链表中存在这个包含 key 的节点，那么就找到这个节点并把它更新后放到链表的头节点；如果 hashmap 不包含这个 key，那么就新建一个节点并在 hashmap 中添加键值对，之后如果链表已满则删除尾节点，把新的节点添加到最前面。&lt;/p&gt;

&lt;h1 id=&quot;多线程&quot;&gt;多线程&lt;/h1&gt;

&lt;h2 id=&quot;多线程的实现方式&quot;&gt;多线程的实现方式&lt;/h2&gt;

&lt;p&gt;pthread：类 Unix 系统提供的操作系统级多线程处理方式，基本用不到&lt;/p&gt;

&lt;p&gt;NSThread：iOS 系统对 pthread 的封装，提供面向对象的操作方式，需要自己创建和开启线程&lt;/p&gt;

&lt;p&gt;GCD：自动管理线程的生命周期，根据系统的 CPU 及其负载进行任务调度。&lt;/p&gt;

&lt;p&gt;NSOperation、NSOperationQueue：分别对应 GCD 的任务和队列。提供了 cancel 操作和设置依赖的功能。&lt;/p&gt;

&lt;h2 id=&quot;同步异步-串行并行&quot;&gt;同步、异步 串行、并行&lt;/h2&gt;

&lt;p&gt;异步任务会开启新的线程，同步任务会在当前线程。异步串行多个任务会在一个开启的新线程中依次执行，异步开启并行任务会开启多个线程乱序执行。&lt;/p&gt;

&lt;p&gt;只要是同步任务（不论是并行还是串行）都会阻塞当前线程，只要是异步任务（不管是并行还是串行）都不会阻塞当前线程。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;当在主线程同步在主队列执行任务时会死锁。&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;实现线程同步的方法&quot;&gt;实现线程同步的方法&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;加锁&lt;/li&gt;
  &lt;li&gt;使用串行队列&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;多线程的弊端和解决方案&quot;&gt;多线程的弊端和解决方案&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;占用内存，上下文需要更新寄存器等操作需要一定耗时&lt;/li&gt;
  &lt;li&gt;产生线程竞争：多个线程共享资源可能会产生与预期不同的结果&lt;/li&gt;
  &lt;li&gt;锁：为了解决线程竞争的问题需要加锁，但是加锁会有性能损失&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;多线程锁&quot;&gt;多线程锁&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt;自旋锁&lt;/th&gt;
      &lt;th&gt;互斥锁&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;概念&lt;/td&gt;
      &lt;td&gt;一直等待资源释放，死循环，处于忙等状态&lt;/td&gt;
      &lt;td&gt;当无法获取需要资源时会进入休眠状态，直到资源可用才会被唤起&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;优势&lt;/td&gt;
      &lt;td&gt;效率高，因为不会休眠，没有唤起和上下文切换的消耗&lt;/td&gt;
      &lt;td&gt;不需要一直占用CPU，在等待过程中 CPU 可以进行其他工作&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;劣势&lt;/td&gt;
      &lt;td&gt;一直占用 CPU，&lt;/td&gt;
      &lt;td&gt;需要进行唤起和上下文切换&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;使用场景&lt;/td&gt;
      &lt;td&gt;锁操作者保持锁操作比较短的情况下&lt;/td&gt;
      &lt;td&gt;锁操作的消耗大于上下文切换的消耗&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;iOS 中的锁&lt;/td&gt;
      &lt;td&gt;OSSpinLock&lt;/td&gt;
      &lt;td&gt;pthread_mutex/NSLock/NSRecursiveLock&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;pthread_mutux 设置 PTHREAD_MUTEX_RECURSIVE 后就成了递归锁，NSLock 是对 pthread_mutux 普通锁的封装，NSRecusiveLock 是对 pthread_mutux 递归锁的封装。&lt;/p&gt;

&lt;p&gt;递归锁：允许统一线程对统一把锁进行重复加锁。解决了递归调用过程中对使用同一把锁多次加锁的问题。&lt;/p&gt;

&lt;p&gt;自旋锁可以解决优先级反转的问题。&lt;/p&gt;

&lt;h2 id=&quot;atomic-真的安全么是怎么实现的用的哪种锁&quot;&gt;atomic 真的安全么？是怎么实现的？用的哪种锁？&lt;/h2&gt;

&lt;p&gt;原子性并不能保证线程安全. 只是相对运用了原子性keyword 的属性来说是线程安全的. 对于类来说则不一定.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;atomic所说的线程安全只是保证了getter和setter存取方法的线程安全，并不能保证整个对象是线程安全的&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;比如对一个 MutableArray 设置了 atomic，只能确保多个线程在 set 和 get 这个属性的时候是线程安全的，但是如果有多个线程在同时操作这个数组（添加、删除元素），那就不是线程安全的了。&lt;/p&gt;

&lt;p&gt;Runtime 中有一个全局数组保存了属性锁 —— 这个锁是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;spinlock_t&lt;/code&gt; 的自旋锁，根据属性在实例中的位置获取到这把锁，加锁后才能操作设置或者获取值，之后再释放锁。&lt;/p&gt;

&lt;h1 id=&quot;tcp&quot;&gt;TCP&lt;/h1&gt;

&lt;h2 id=&quot;握手&quot;&gt;握手&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;客户端向服务端发送一个不包含应用数据的报文段。SYN=1 和 随机的起始序号（seq=client_isn）&lt;/li&gt;
  &lt;li&gt;服务端向客户端发送一个不包含应用数据的允许连接报文段。SYN=1  ACK=client_isn+1 和随机起始序号（seq=server_isn）。服务端分配缓存和变量&lt;/li&gt;
  &lt;li&gt;客户端再次确认。ACK=server_isn+1 SYN=0。客户端分配缓存和变量&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;断开&quot;&gt;断开&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;客户端向服务端发送报文段，客户端进入 FIN_WAIT_1 状态。FIN=1 和一个序号 seq=x（根据上一个序号）&lt;/li&gt;
  &lt;li&gt;服务端回送确认报文段，服务端进入 CLOSED_WAIT 状态，客户端收到后进入 FIN_WAIT_2 状态。ACK=1 ACKnum=x+1&lt;/li&gt;
  &lt;li&gt;服务端发送终止报文段，服务端进入 LAST_ACK 状态。FIN=1 seq=y（根据上一个序号）&lt;/li&gt;
  &lt;li&gt;客户端确认终止报文段，客户端进入 TIME_WAIT 状态，服务端收到后进入 CLOSED 状态，客户端等待 2MSL 后关闭连接。ACK=1 ACKnum=y+1&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;握手或者挥手次数为什么需要3次和四次，能少一次吗？&lt;/p&gt;

&lt;p&gt;不能，需要这些次数的原因是防止报文在传递过程中出现丢包或者超时的问题。比如说在握手阶段如果没有第三个报文，那么服务端无法确认客户端是否收到了自己发送的确认报文，那就没办法确定后面到来的 TCP 报文的正确和安全性。&lt;/p&gt;

&lt;h1 id=&quot;ssl&quot;&gt;SSL&lt;/h1&gt;

&lt;h2 id=&quot;握手-1&quot;&gt;&lt;strong&gt;握手&lt;/strong&gt;&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;客户发送它支持的密码算法列表，连同一个客户的不重数。&lt;/li&gt;
  &lt;li&gt;从该列表中，服务器选择一种对称算法（如AES）、一种公钥算法（如RSA）和一种MAC算法。它把它的选择以及证书和一个服务器不重数返回给客户。&lt;/li&gt;
  &lt;li&gt;客户验证该证书，提取服务器的公钥，生成一个前主密钥（Pre-Master Secrete, PMS），用服务器的公钥加密该 PMS，并将加密的 PMS 发送给服务器。&lt;/li&gt;
  &lt;li&gt;使用相同的密钥导出函数，客户和服务器独立地从 PMS 和不重数中计算出主密钥（Master Secrete，MS）。然后该 MS 被切片以生成两个密码和两个 MAC 密钥。此外，当选择的对称密码应用于 CBC（例如 3DES 或 AES），则两个初始化向量（IV）也从该 MS 获得，这两个 IV 分别用于该连接的两端。自此以后，客户和服务器之间发送的所有报文均被加密和鉴别（使用 MAC）。&lt;/li&gt;
  &lt;li&gt;客户发送所有握手报文的一个 MAC。&lt;/li&gt;
  &lt;li&gt;服务器发送所有握手报文的一个 MAC。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;最后两步使握手免遭篡改。&lt;/p&gt;

&lt;h2 id=&quot;断开-1&quot;&gt;&lt;strong&gt;断开&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;通过终止 TCP 连接来结束 SSL 会话。为了防止被截断攻击就在类型字段中指出该记录是用于终止 SSL 会话的。接收方通过使用的 MAC 就可以得知是否是一个正常的关闭。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;最后，如果有人问你某一个知识点的 API 是什么，你就转身走人。&lt;/p&gt;</content><author><name></name></author><summary type="html">你喜欢”八股文“吗？</summary></entry><entry><title type="html">搞定移动端系统设计面试</title><link href="http://localhost:4000/ios/cracking-the-mobile-system-design-interview/" rel="alternate" type="text/html" title="搞定移动端系统设计面试" /><published>2022-03-01T20:33:35+08:00</published><updated>2022-03-01T20:33:35+08:00</updated><id>http://localhost:4000/ios/ios-system-design</id><content type="html" xml:base="http://localhost:4000/ios/cracking-the-mobile-system-design-interview/">&lt;p&gt;自从系统设计相关面试题被引入面试流程以来，它已经成为 FAANG 等各大互联网公司最喜爱的一类问题。过去这类问题只出现在后端的面试中，近几年开始被引入客户端的面试流程里。&lt;/p&gt;

&lt;p&gt;系统设计类面试题与其他类型的问题相比，能够更全面、更深入的考察我们的设计和架构能力。&lt;/p&gt;

&lt;!-- more --&gt;

&lt;p&gt;&lt;img src=&quot;../../images/first/system-design-interview.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;关注公众号“iOS开发栈”，了解更多iOS开发知识&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;系统设计面试题主要集中在两个主题中（设计和架构）。作为一个候选人，你更可能被安排移动端应用程序或某个特性的设计任务。比如说：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;设计一个图片分享应用（例如：Instagram）&lt;/li&gt;
  &lt;li&gt;设计一个即时通讯应用（例如：WhatsApp、Messenger、微信）&lt;/li&gt;
  &lt;li&gt;设计一个信息流应用（例如：Twitter、微博）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这类问题的目的是让你描述你是怎么把一系列抽象的需要转变成精确具体的解决方案的过程。它也让你的面试官通过你在不同方案之间的取舍来对你的技术深度有一个整体印象。&lt;/p&gt;

&lt;p&gt;在当前富有竞争力的人才市场中，不管是大型技术公司还是小的初创公司都希望有一种新的流程来让他们能够筛选出天才程序员。正因如此，越来越多的公司开始采用这种系统设计的面试题来取代其他形式。&lt;/p&gt;

&lt;p&gt;如果你之前没有经历过或者对系统设计没有很丰富的经验，那么你可能对系统设计类的面试有点害怕。移动端系统设计面试是怎么设置的有一层神秘的面纱。如果你之前搜索过系统设计相关的问题或者面试题，你可能已经意识到现在网上的很多相关资料（面试题、书籍、视频）绝大多数都是针对后端开发工程师的，针对移动端的非常少。我们也遇到了这个问题，这就是为什么我决定分别从候选人和面试官的角度来分享这篇文章的原因。&lt;/p&gt;

&lt;p&gt;你很快就会发现这并没有什么可怕的。通过一些指导和练习，你完全可以放心大胆地准备并通过这类面试。最终你可能会爱上它。&lt;/p&gt;

&lt;h1 id=&quot;系统设计面试流程&quot;&gt;系统设计面试流程&lt;/h1&gt;

&lt;p&gt;大多数的系统面试会持续大概45分钟（最多不超过1个小时），主要有这几个步骤：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;6 - 8 分钟：面试官介绍和简短的开场白&lt;/li&gt;
  &lt;li&gt;4 - 5 分钟：问题陈述&lt;/li&gt;
  &lt;li&gt;25 - 30 分钟：设计并讨论你的解决方案&lt;/li&gt;
  &lt;li&gt;5 分钟：候选人向面试官提问&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;我看到大多数候选人——包括我自己会犯的一个非常典型的错误是认为自己有45分钟来解决问题，因为整个面试时间有 45 分钟。而实际上，正如你从上面看到的，你只有大概 30 分钟的时间来设计你的方案。因此，抓住时间是重要的。好好分配这 30 分钟的时间，尽力多地覆盖你掌握的知识。甚至在这仅有的 30 分钟时间中，也会有中断——面试官提问。因此，最好能够有一个清晰的计划并且进行充足的练习，以此确保你能搞定它。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;💡Tip: 当你练习的时候，进行倒计时并迫使自己在 30 分钟内完成。之后，回顾你涉及到的主题，如果还有剩余时间就继续添加一些可以说的内容。每次联系完都要问问自己是不是把绝大多数相关主题都涉及到了？还有没有能够添加进来的内容？如果是的话，你要怎么把这些问题放进来呢？进行这些联系能够让你创造一个固定的路径和慢慢培养感觉。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;面试官视角&quot;&gt;面试官视角&lt;/h1&gt;

&lt;p&gt;在开始进入具体的面试之前，我们需要先了解桌对面的人 —— 面试官的视角。他们在寻找什么呢？&lt;/p&gt;

&lt;p&gt;开放形式的面试目的是找到你的知识边界。让你选择你想要谈论的题目并且看看施行方案的时候，你是怎么考虑它们的。他们设计这种方式以便让面试官衡量接下来的事情：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;你模糊问题的能力。通过询问正确答案来处理，来将它分割成一系列具体的需求&lt;/li&gt;
  &lt;li&gt;你的思考过程：在保持整个系统连接和完成所有需求的同时，你是怎么把一个大问题分割成更小的部分的&lt;/li&gt;
  &lt;li&gt;你是怎么做决定的，评估不同的方案并做出取舍&lt;/li&gt;
  &lt;li&gt;你的知识，你更熟悉 iOS 或 Andorid 的哪一部分。你能给服务端提出建议吗？&lt;/li&gt;
  &lt;li&gt;最后但并不是最不重要的一条，你的交流和合作能力。你是怎么同步你的方案并赢得信任的&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这里并没有正确或错误的答案 —— 只有不同的角度。并且你的面试官知道这个。因此不要关注在寻找最完美的方案上。而是集中精力设计一个在你的日常工作中每天都要使用的方案，运用你的知识来强化你的优势。有一次别人给我了一个建议 —— 对我一直有帮助，专注在你了解的东西。如果面试官真的想要让你成功，他们会对你了解的东西更有兴趣而不是你不了解的。另外，如果你能够更快的完成方案设计并且证明行之有效，那你会获得额外的分数。大多数情况下，最初的问题不会是整个练习，面试官会继续涵盖一些其他问题。这也就为什么接下来是一个循序渐进的过程，最开始是一个高屋建瓴的“更简单”答案，随着新需求的提出不断发展它，效果相对较好。&lt;/p&gt;

&lt;p&gt;在面试期间选择你熟悉的领域是一把双刃剑。这给了你掌握对话和在你更熟悉的部分探索的自由，但是同时，面试官会假设那些你没有涉及到的内容就是你不知道的。记住，绝大多数面试官（尤其是大公司的）倾向于更保守的写下自己的评价。因此，最棘手的一点就是怎么在简短的涵盖问题所涉及的所有主题的同时又能深入到某些相关问题中之间取得适当的平衡。&lt;/p&gt;

&lt;p&gt;掌握这个平衡点是非常困难的，主要是因为你和你的面试官关注的点不一样。幸运的是，大多数面试官会为你提供帮助。当你对他们关注的点有所纰漏的时候，他们会提示你，甚至会让你直接解决他们感兴趣的地方。因此，对你来说最好是认真听取面试官的提示，此外，如果不要害怕对自己有疑惑的地方提出问题。&lt;/p&gt;

&lt;h1 id=&quot;搞定系统设计面试的技巧&quot;&gt;搞定系统设计面试的技巧&lt;/h1&gt;

&lt;p&gt;下面是搞定移动端系统设计相关面试的策略。我已经在多年的面试中使用过这个策略，并且看到了许多成功的候选人表现出色。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;💡Tip: 不要把这个策略当作万能药。我鼓励你花时间理解它，学习每一步的重要性和目标，并且把这变成你自己的。世界上没有两个完全相同的候选人，你自己最清楚什么东西更适合你。你有技巧，有经验，自信点。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这个策略由下面六步组成：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;理解问题&lt;/li&gt;
  &lt;li&gt;定义范围&lt;/li&gt;
  &lt;li&gt;明确技术要求&lt;/li&gt;
  &lt;li&gt;提出高层设计&lt;/li&gt;
  &lt;li&gt;深入某一部分&lt;/li&gt;
  &lt;li&gt;圆满完成&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;让我们更详细地理解这六步吧！&lt;/p&gt;

&lt;h2 id=&quot;理解问题&quot;&gt;理解问题&lt;/h2&gt;

&lt;p&gt;第一步应该是理所当然的。在构建方案前，我们需要理解问题。&lt;/p&gt;

&lt;p&gt;这可能是最显而易见的一步，并且也是大多数候选人失败的地方，包括我自己 —— 很多次。为什么？因为我太快的跳到结论了。但是对我们来说这并不难。我们多数人会跳入陷阱是有原因的，正是因为众所周知的成见 —— 面试环境 —— 我们太想要证明自己了。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;“跳跃式结论偏差，也称为推理-观察混淆，是一个心理学术语，指的是在没有足够信息来确定一个人/事是正确的情况下做出决定，这可能会导致糟糕或草率的决定，往往会造成更大的伤害。”来源于：&lt;a href=&quot;https://en.wikipedia.org/wiki/Jumping_to_conclusions&quot;&gt;Wikipedia&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;因此，现在你知道它了，不要再直接跳到结论了。减缓你想要开始设计方案的想法，并且避免成为那种在还没有理解题意的情况下直接跳到答案的候选人。取而代之的是，把面试官想让你关注的点具体化，这类应用程序最大的跳转是什么，以及之前你是怎么处理类似的问题的。&lt;/p&gt;

&lt;p&gt;这也是面试官之所以给你一个模糊的、开放的问题的原因，这一步正是要细化它。记住，她正在评估你分析一个未完成问题的能力，识别出盲区，并提出正确的问题。&lt;/p&gt;

&lt;p&gt;因此，在这一步，你想要提出清晰的问题来理解整个场景。思考你获得的信息之后提出相关问题来完成整个题目的全貌。&lt;/p&gt;

&lt;p&gt;这里有几个我认为适合在此阶段提出的问题，取决于具体的题目：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;我们被要求设计什么东西？&lt;/li&gt;
  &lt;li&gt;用户是谁，他们会怎么使用这个系统？&lt;/li&gt;
  &lt;li&gt;初始用户规模是多少？预期增长是多少？&lt;/li&gt;
  &lt;li&gt;给我们基础设计或者范围了吗，我们应该自己提出一个吗？&lt;/li&gt;
  &lt;li&gt;我们是在设计 MVP（Most Valuable Product）还是最终产品呢？&lt;/li&gt;
  &lt;li&gt;我们是从最开始构建吗，或者我们可以利用其他已经存在的部件？我们能利用哪个模式或者架构呢？&lt;/li&gt;
  &lt;li&gt;实现并维护这个产品的组有多少人？&lt;/li&gt;
  &lt;li&gt;我们只用实现移动端还是包括整个系统的其他部分（例如 API）？&lt;/li&gt;
  &lt;li&gt;只用做 iOS 或 Android 端，还是要跨平台？要支持手机、桌面，还是都有？&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;你不需要问上面的所有问题，要根据具体的题目和已经得到的信息提问。对某个题目来说，只有某些相关问题需要优先考虑。&lt;/p&gt;

&lt;h2 id=&quot;定义范围&quot;&gt;定义范围&lt;/h2&gt;

&lt;p&gt;第二步是找到对这个 App 来说你需要的功能或特性，并与面试官取得一致意见。&lt;/p&gt;

&lt;p&gt;想想你使用过的类似的著名应用或系统，他们是怎么处理类似问题的。他们提供了哪些功能，哪些是主要功能。你可以建议一些你能想到的潜在功能，并就你要集中讨论的功能点与面试官取得一致。这应当是面试中协作的一部分。&lt;/p&gt;

&lt;p&gt;一旦范围清晰了并且面试官也没有异议，你就可以准备进行下一步了，慢慢展开你的方案。&lt;/p&gt;

&lt;h2 id=&quot;明确技术要求&quot;&gt;明确技术要求&lt;/h2&gt;

&lt;p&gt;真正有意思的地方从这里开始！一旦功能要求清晰了，你应该换个思路，开始考虑构建一个能够提供所需用户体验的解决方案所必需的技术方案。&lt;/p&gt;

&lt;p&gt;让我们直接进入到设计移动端应用通常需要考虑的方面：&lt;/p&gt;

&lt;h3 id=&quot;网络&quot;&gt;网络&lt;/h3&gt;

&lt;p&gt;现在大多数应用程序都需要从后端获取或者分享它们的状态。花费一些时间来考虑服务端，大多数情况下，服务端提供 REST API。已经有 API 了吗？如果有的话，它们是什么样的？&lt;/p&gt;

&lt;p&gt;有没有功能必须要低延迟来模拟实时更新？如果有的话，你要怎么把信息推送到客户端？你可能需要比 HTTP 请求更复杂的方案。你可能要使用 push notifications、WebSockets、polling 等等。你需要考虑这些选项的优劣和作出的取舍。&lt;/p&gt;

&lt;h3 id=&quot;安全性&quot;&gt;安全性&lt;/h3&gt;

&lt;p&gt;正如我们上面提到的大多数应用程序都需要和其他系统交互。那么保证这些通讯的安全性就是显而易见的了。考虑下面的话题：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;授权（Authentication）&lt;/strong&gt;：你的方案是怎么进行用户验证的，怎么确保提供了访问的正确等级&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;存储敏感数据（Storing sensitive data）&lt;/strong&gt;：你需要保存用户凭证吗？当然！除非你想提供给用户每次都要登录的糟糕体验。哪种凭证呢（access token，refresh token）？我们要处理个人验证信息（PII）吗？你要怎么安全的存储这些内容（Keychain，Smart Lock）？&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;安全通讯（Secure communications）&lt;/strong&gt;：你要怎么保证和服务端的通讯安全性？例如所有请求都用 HTTPS。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;可用性&quot;&gt;可用性&lt;/h3&gt;

&lt;p&gt;应用程序要提供离线模式吗？大多数应用都会，只要你不想每次打开的时候都从空页面开始。你会用一个本地存储来缓存数据（例如 Core Data，Realm，SQLite，shared preferences等），考虑哪一个和原因。&lt;/p&gt;

&lt;p&gt;对于图片和其他媒体数据呢？如果可能的话，当从网络获取之后，你可以把它们缓存到本地。这是一个好的选择，但是它也带来了一些挑战：一次处理多个请求，取消过期请求，清理策略（例如：LRU），限制同步请求数，等等。&lt;/p&gt;

&lt;h3 id=&quot;可扩展性&quot;&gt;可扩展性&lt;/h3&gt;

&lt;p&gt;移动端的可扩展性和其他系统有些不同，在服务端面试中，你需要设计系统来支持百万 QPS、分块存储数TB的数据。在移动应用中，扩展性通常联系着代码量和团队人员的增加。因此，考虑你是怎么为新特性进行设计的，以及怎么处理团队人数增加的。&lt;/p&gt;

&lt;p&gt;你应该：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;把界面分割成更小的部分。&lt;/strong&gt;以便不同的人可以高效的工作在不同的工作栈中&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;界面标准化&lt;/strong&gt;。通过构建可复用的 UI 库，可以在跨 app 的时候减少代码量和确保稳定性&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;模块化（组建化）&lt;/strong&gt;：把功能分割成独立的模块（一个团队可以负责一块），并且提取可复用组件做成共享的核心模块。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;性能&quot;&gt;性能&lt;/h3&gt;

&lt;p&gt;现在的移动端生态系统越来越多的应用程序通过提供平滑、流畅的用户体验来增加辨识度。要做到这样，你需要面对隐藏从服务端获取数据的挑战。&lt;/p&gt;

&lt;p&gt;你可能会涉及到的关于性能相关话题：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;有 UI 敏感操作吗（例如 无限滚动，大量动画，复杂交互）？你要怎么支持这些？例如，你可能要提前加载数据并建立缓存。&lt;/li&gt;
  &lt;li&gt;应用要加载大量数据吗 —— 图片、音频、视频？如果是的话，我们应该考虑怎么异步处理它们，因此我们确保界面流畅来持续提供尽可能好的用户体验，例如，通过把获取数据和刷新 UI 区分开。在你的方案中，什么可能会成为瓶颈或挑战？&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;测试&quot;&gt;测试&lt;/h3&gt;

&lt;p&gt;你可以简短的提到关于怎样保证 app 质量的问题。现在，默认方案是提供可依赖的测试套件，但是具体细节需要根据具体需求（例如 是否只是一个 MVP 产品）。你或许想要考虑并描述你的测试策略。&lt;/p&gt;

&lt;p&gt;你可能会简短的讨论下面的话题：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;解释一个测试策略：你会怎么采用不同的测试类型（单元测试，集成测试，界面测试来全面覆盖应用流程）&lt;/li&gt;
  &lt;li&gt;强调你的架构是如何让测试每一个部件变得容易的&lt;/li&gt;
  &lt;li&gt;使用依赖注入来简化测试&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;监控&quot;&gt;监控&lt;/h3&gt;

&lt;p&gt;通常你不需要花费太长时间在这一部分，除非面试官问你。解释你的设计是如何确保系统正确性并在发生错误时快速反应是非常重要的。两个最重要的支柱是：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;崩溃报告和日志&lt;/li&gt;
  &lt;li&gt;统计分析&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;部署&quot;&gt;部署&lt;/h3&gt;

&lt;p&gt;你是怎么预见系统上线的？这取决于面试官的要求。通常需要提高的话题有：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;带有自动发布的持续集成（CI/CD）。（例如 Fastlane _lanes _to send builds to production, QA and beta)&lt;/li&gt;
  &lt;li&gt;利用远程功能标记来逐步推出更改，并将发布和审查分开（例如 确保新特性已经准备好面向市场）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这是本步所有内容！&lt;/p&gt;

&lt;p&gt;哦。。。这些内容太多了，时间太紧了！不要紧张，目标是让你提高它们中尽量多的内容（一或者两句话），以便面试官知道你都考虑到了。除非它对题目是重要的或者面试官问到，否则不需要很详细。（记住，仔细听面试官的提示）。&lt;/p&gt;

&lt;h2 id=&quot;提出高层设计&quot;&gt;提出高层设计&lt;/h2&gt;

&lt;h3 id=&quot;画出主要流程如果没有提供的话&quot;&gt;画出主要流程（如果没有提供的话）&lt;/h3&gt;

&lt;p&gt;如果你还没有得到流程图，在你深入开发之前的第一步是画出它们。这一步是至关重要的。这会让你和面试官同意主要的界面，UI 组件，用户交互和导航流程，之后这些会提示你的技术决策。你要确保你设计的功能满足给定的要求，并取得面试官的认可。&lt;/p&gt;

&lt;p&gt;遵循下面三个简单的步骤，这将会是非常简单的：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;画出主要界面&lt;/strong&gt;，描述界面中的主要内容&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;梳理流程&lt;/strong&gt;，根据用户的使用路径画出箭头&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;添加细节&lt;/strong&gt;，讨论每一个界面的组成：找出主要的 UI 元素，分割 UI 组件（例如 CollectionView/TableView 中的 cards/cells）。考虑可能重用的元素。&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;💡Tip：不要花太多时间画一个高保真线框图。考虑最重要的：描述用户体验，集中在不同的界面和它们的组件，以及用户流程。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;画出主系统如果需要&quot;&gt;画出主系统（如果需要）&lt;/h3&gt;

&lt;p&gt;在这里，你应该询问面试官是想让你涵盖端到端系统还是仅仅是客户端。大多数移动端设计面试只专注于 app，但是这取决于你面试的岗位，用人单位要找的工程师类型和团队大小，他们会想你至少描述你对 app 之外的内容有基础的了解。&lt;/p&gt;

&lt;p&gt;假设面试官让你设计的是一个端到端的系统。你通常要设计的元素有：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;移动端&lt;/li&gt;
  &lt;li&gt;API 服务（客户端会交互的那一层）&lt;/li&gt;
  &lt;li&gt;后端&lt;/li&gt;
  &lt;li&gt;数据存储（云上存储信息）&lt;/li&gt;
  &lt;li&gt;通知服务（如果需要的话）&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;定义基础的数据实体&quot;&gt;定义基础的数据实体&lt;/h3&gt;

&lt;p&gt;在这里，你应该对你的设计和你的应用程序功能有一个好的概念。描述对你的问题最重要的数据实体应该是非常容易的。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;💡Tip：不要过于深入细节。你并不是在设计一个数据库引擎。你只想列出实体（例如 users、posts、comments），提一下他们最相关的属性和关系。如果你的面试官询问细节，你可以继续深入。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;描述主要的端点需要的话&quot;&gt;描述主要的端点（需要的话）&lt;/h3&gt;

&lt;p&gt;取决于在你之前的询问中，面试官说的 API 是否已经提供，你或许需要设计断点。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;💡Tip：随着方法的迭代，不要提出完全的端点规格。列出端点使用的 HTTP 方法（GET、POST、PUT、DELETE）和路径（例如 GET /post/:id/comments），端点需要的输入和输出参数。对于输出，不要写出完整的实体内容。和前面一样，向面试官确认。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;提出客户端架构&quot;&gt;提出客户端架构&lt;/h3&gt;

&lt;p&gt;回到应用中，是时候讨论并决定你的设计使用的架构和设计模式了。&lt;/p&gt;

&lt;p&gt;回想你熟悉的标准架构（例如 MVC、MVP、MVVM+C、VIPER、RIBs 等），还有最常用的设计来在你的系统不同层上抽象和包装逻辑（例如 Repositories，Use Cases，Services 等等）。针对你的题目考虑它们的优势和劣势。哪一个更适合这个需求呢？为什么？&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;💡Tip：选择一个干净的架构会让你接下来的练习更加容易。这些架构使你的设计更容易分成更小的、独立的部分，来提高系统的可扩展性，灵活性和可测试性。记住，你的面试官或许以一个相对简单的问题开始，之后让你把它扩展到更复杂的场景。你的架构越灵活的应对新挑战，你的系统就会容易的处理更复杂的场景。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;不幸的是，我无法告诉你最好的架构。这不仅依赖于你面对的问题，还有你的经验。如果你对它的认识不够，选择一个新架构也许是个错误。然而，我建议你选择你熟悉的，当你需要在面试中描述它的细节时，充分理解你架构的每一部分是基础。&lt;/p&gt;

&lt;p&gt;于我来说，我倾向于使用更简单的，与趋势无关的干净架构，由以下几部分组成：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;展示层（UI）&lt;/strong&gt;：MVVM + Coordinator，来处理 view &amp;amp; controller 或者 activities &amp;amp; fragments，以及界面导航。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;业务层&lt;/strong&gt;：从用户和仓库组织数据&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;数据层&lt;/strong&gt;：
    &lt;ul&gt;
      &lt;li&gt;仓库，从网络和本地存储获取数据&lt;/li&gt;
      &lt;li&gt;网络数据：典型 API 客户端的各个端点&lt;/li&gt;
      &lt;li&gt;持久化层：本地存储（如果有缓存的话）&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;辅助服务&lt;/strong&gt;：从不同功能中提取出来的函数，例如
    &lt;ul&gt;
      &lt;li&gt;网络服务&lt;/li&gt;
      &lt;li&gt;Session 服务&lt;/li&gt;
      &lt;li&gt;凭证存储&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当使用标准组件的时候，我发现保持架构与趋势无关是有帮助的。我更喜欢根据实际问题添加需要的部分，而不是固执己见的选择（例如 VIPER）。这显然是一个个人习惯问题，你和你的面试官可能持不同态度。因此，我的建议是在练习时与她谈判，解释你所采取选择的权衡。&lt;/p&gt;

&lt;h2 id=&quot;深入某一部分&quot;&gt;深入某一部分&lt;/h2&gt;

&lt;p&gt;是时候开始练习某一部分的细节了。当能够在高层次下给出好的解决方案，你的面试官更期望你能够深入浅出的描述设计组件。&lt;/p&gt;

&lt;p&gt;这里有几个我采取的方法：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;选择最有趣的界面并画出它的架构&lt;/strong&gt;：包括不同界面元素的所有层级，VMs，Repos，Endpoints/Sockets，Network Layer，Local Store等等&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;描绘依赖&lt;/strong&gt;，画出调用箭头&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;通过工作流&lt;/strong&gt;，从用户视角出发：用户体验是什么？每一步用户看到的是什么？描述可能的界面状态：Loading，Error，No Data，Data&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;解释数据流&lt;/strong&gt;：数据转化随着这样的路径：NetworkModel -&amp;gt; Business Model -&amp;gt; View State Model。画出来展示数据流（不同于依赖箭头，例如 使用虚线箭头或另一种颜色）&lt;/li&gt;
  &lt;li&gt;一旦你完成了上面所有内容，&lt;strong&gt;深入其中一个部分&lt;/strong&gt;。考虑哪些东西可能成为最大的挑战，这个设计是否会有瓶颈，例如：
    &lt;ul&gt;
      &lt;li&gt;实时刷新&lt;/li&gt;
      &lt;li&gt;图片缓存（挑战，NSOperation Queue）&lt;/li&gt;
      &lt;li&gt;Cell复用（准备 VMs）&lt;/li&gt;
      &lt;li&gt;数据缓存&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;💡Tip：再说一次，仔细听面试官说的。大多数面试官会让你选择一个或一些，但是也有一些会指定她向让你说的。或许，如果你忘记了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;圆满完成&quot;&gt;圆满完成&lt;/h2&gt;

&lt;h3 id=&quot;快速回顾你的设计&quot;&gt;快速回顾你的设计&lt;/h3&gt;

&lt;p&gt;回顾最初的范围和功能需求，以及你的设计是怎么满足它们的。&lt;/p&gt;

&lt;h3 id=&quot;后续问题延伸目标&quot;&gt;后续问题/延伸目标&lt;/h3&gt;

&lt;p&gt;在这里，你的面试官也许已经问你后续问题了。仔细听这些问题并且解释你的设计是怎么支持它们的。另外，问问她还有没有其他内容需要你展开讲。&lt;/p&gt;

&lt;h3 id=&quot;进一步精炼和考虑&quot;&gt;进一步精炼和考虑&lt;/h3&gt;

&lt;p&gt;简短的涉及一些你能做的改进，如果你还有时间的话：仔细检查你上面的设计和技术考量，想一下哪里还有可以展开详细讲的。思考一下你刚才可能遗漏的技术考虑，现在或许是时候简短的提高它们了。对于你的一些想法的测试策略会是什么样？你会怎么使用 crash 上报和分析来确保系统正确性？你是怎么通过可访问性来保证程序的包容性的？&lt;/p&gt;

&lt;h2 id=&quot;最后一点&quot;&gt;最后一点&lt;/h2&gt;

&lt;h3 id=&quot;通用建议&quot;&gt;通用建议&lt;/h3&gt;

&lt;p&gt;我们已经在描述我们方法的不同步骤中涵盖了很多内容了（我希望这些东西现在已经成你的了）。通过这些，你或许已经注意到一个通用的设计套件。让我们快速的过一遍：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;不要害怕提问&lt;/strong&gt;：题目往往是模糊的，你需要收集必要信息来确保你解决的问题就是面试官想让你解决的。只有一个方法能做到：向面试官提问。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;验证你的假设&lt;/strong&gt;：向面试官检查你做出的假设，确保你的方向没有问题。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;知道并使用你的工具&lt;/strong&gt;：真正擅长绘制图表和同步方案。时间很宝贵，这会催促你加快速度。无论是一个白板还是在线工具，练习以一种清晰易懂的方式来构建你的想法。学习让你的图表更容易修改和扩展。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;分享你的想法&lt;/strong&gt;：要想使面试更有效率，你就要持续地与面试官交流。记住，她想要理解你想的东西。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;为你的选择买单&lt;/strong&gt;：对于你做的每一个决定，提及你考虑的不同替代方案，它们的优势和劣势，以及你为什么选择这一个和为此做的取舍。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;练习练习练习&quot;&gt;练习，练习，练习&lt;/h3&gt;

&lt;p&gt;我已经提到了练习的重要性，练习可以提高这类面试成功的几率。现在，你或许好奇应该怎么做。这里有几个工作很好的建议：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;熟悉不同的标准架构&lt;/strong&gt;：MVC，MVVM，MVP，Redux，VIPER 等&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;设计常见应用&lt;/strong&gt;：拿起你的手机，想一下你常用的应用以及它们最著名、最具挑战的功能（例如 Mail client、Instagram、Spotify、Twitter、Facebook、WhatsApp、Etsy），之后想一下你会怎么设计它。拿起一张纸开始设想你会怎么实现这些应用。这种简单的练习对大多数人都非常行之有效。相信我：这确实有用！&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;阅读已经存在的方案&lt;/strong&gt;：查阅来自大公司工程师的博客文章、录像等，比较一下他们是怎么解决这些挑战的。&lt;/li&gt;
  &lt;li&gt;回顾一些有名的&lt;strong&gt;开源项目&lt;/strong&gt;。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;询问朋友和同事&lt;/strong&gt;来检查你的设计，去的反馈。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;练习模拟面试&lt;/strong&gt;，和同事或者其他候选人一起。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;放松并享受过程&quot;&gt;放松并享受过程&lt;/h3&gt;

&lt;p&gt;系统设计面试确实很难，有些让人不知所措，但是这也是富有创造性的，并且让你构想你从没有参与过的系统。准备任何面试都是充满压力的，但是如果你学会享受准备本身，这就成了一个能扩展你知识面的机会，这可以成为令人兴奋的体验。&lt;/p&gt;

&lt;h1 id=&quot;因此关于即将到来的面试&quot;&gt;因此，关于即将到来的面试&lt;/h1&gt;

&lt;p&gt;如果你正在阅读这篇文章，你很可能正在准备一场面试。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;移动端系统设计面试就像一个智力游戏&lt;/strong&gt;。一个你之前从没有做过的游戏，但是你可以带上这些部分来解决它。因此，请确保在您的工具箱中包含一组广泛的零件，并乐于仔细检查它们并选择最适合工作的零件。&lt;/p&gt;

&lt;p&gt;这这篇文章中，我已经尽力分享面对这些面试的方法。但是这只是我的方法，这个方法我已经自己使用了几十次，并面试了几百个候选人。当描述它的时候，我的目的是尽力多的涵盖可能的话题，因此你可以形成适合你自己的策略。&lt;strong&gt;不要只是拿走我的方法，做你自己的！&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在面试之前多练习可以做的更好，但并不是让你死记硬背。没有两个完全相同的系统设计面试，就像没有两个相同的候选人或面试官。记住，面试官引导你并想要让你成功。请&lt;strong&gt;注意面试官给的小提示和建议&lt;/strong&gt;并将这些小数据整合到您的解决方案中。&lt;/p&gt;

&lt;p&gt;感谢你读完一篇这么长的文章。我希望你会对移动端系统设计有一个更好的理解：它们的组成部分，面试官会如何评价，赢得面试的可靠方法。&lt;/p&gt;

&lt;p&gt;如果你能分享你的经历，我会非常高兴。如果你有任何提示或者不同的策略请通过公众号分享给我。&lt;/p&gt;

&lt;p&gt;祝你旗开得胜！&lt;/p&gt;

&lt;p&gt;——————————————————————————————&lt;/p&gt;

&lt;h1 id=&quot;资源&quot;&gt;资源&lt;/h1&gt;

&lt;p&gt;这里有一个简单的资料列表（文章，WWDC 视频，课程 等）来深入和扩展你在不同话题上的知识。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;App Architecture - iOS Application Design Patterns in Swift by Chris Eidhof, Matt Gallagher, and Florian Kugler. [&lt;a href=&quot;https://www.objc.io/books/app-architecture/&quot;&gt;Book&lt;/a&gt;]&lt;/li&gt;
  &lt;li&gt;
    &lt;table&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;33 Engineering Challenges of Building Mobile Apps at Scale by Gergely Orosz [&lt;a href=&quot;https://blog.pragmaticengineer.com/10-engineering-challenges-due-to-the-nature-of-mobile-applications/&quot;&gt;Post&lt;/a&gt;&lt;/td&gt;
          &lt;td&gt;&lt;a href=&quot;https://www.mobileatscale.com/&quot;&gt;Book&lt;/a&gt;]&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;table&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;System Design Interview: an Insider’s Guide by Alex Xu [&lt;a href=&quot;https://www.mobileatscale.com/&quot;&gt;Book&lt;/a&gt;&lt;/td&gt;
          &lt;td&gt;&lt;a href=&quot;https://courses.systeminterview.com/courses/system-design-interview-an-insider-s-guide&quot;&gt;Course&lt;/a&gt;]&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;Push technology. Wikipedia [&lt;a href=&quot;https://en.wikipedia.org/wiki/Push_technology&quot;&gt;Article&lt;/a&gt;]&lt;/li&gt;
  &lt;li&gt;Advances in Networking, Part I. WWDC 2019 [&lt;a href=&quot;https://developer.apple.com/videos/play/wwdc2019/712/&quot;&gt;Video&lt;/a&gt;]&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;关注公众号“iOS开发栈”，了解更多iOS开发知识&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这篇文章翻译自&lt;a href=&quot;https://themobileinterview.com/cracking-the-mobile-system-design-interview/&quot;&gt;The MOBILE INTERVIEW&lt;/a&gt;&lt;/p&gt;</content><author><name></name></author><category term="系统设计" /><summary type="html">自从系统设计相关面试题被引入面试流程以来，它已经成为 FAANG 等各大互联网公司最喜爱的一类问题。过去这类问题只出现在后端的面试中，近几年开始被引入客户端的面试流程里。</summary></entry><entry><title type="html">鸟瞰 Objective-C Runtime</title><link href="http://localhost:4000/ios/what-is-runtime/" rel="alternate" type="text/html" title="鸟瞰 Objective-C Runtime" /><published>2022-02-27T01:21:11+08:00</published><updated>2022-02-27T01:21:11+08:00</updated><id>http://localhost:4000/ios/what-is-runtime</id><content type="html" xml:base="http://localhost:4000/ios/what-is-runtime/">&lt;p&gt;如果你做过 iOS 开发那你肯定知道 Runtime，作为 Objective-C 语言的基石，Runtime 渗透到 iOS 开发的方方面面。从函数调用到内存管理，再到对象构建都离不开 Runtime 的身影。&lt;/p&gt;

&lt;p&gt;这篇文章将从整体视角概括一下 Runtime 的几个话题：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Runtime 是什么，有什么作用？&lt;/li&gt;
  &lt;li&gt;Runtime 是怎么使用的？&lt;/li&gt;
  &lt;li&gt;我们能用 Runtime 做什么？&lt;/li&gt;
&lt;/ol&gt;

&lt;!-- more --&gt;

&lt;p&gt;&lt;img src=&quot;../../images/first/runtime.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;runtime&quot;&gt;Runtime&lt;/h1&gt;

&lt;p&gt;从工程学的本质上讲 Runtime 就是一个用 C/C++ 写的项目。这个项目被用来实现 Objective-C 这门语言，如果你想的话，它也可以用来实现其他语言（Objective-D ?)。&lt;/p&gt;

&lt;p&gt;编程语言可以分成机器语言（二进制、汇编）和高级语言（C、Java等），这样划分的标准是&lt;em&gt;是否能够直接被机器识别&lt;/em&gt;。高级语言之所以高级是因为能够直接被人类读懂，而为了做到这一点就要做出时间、空间上的牺牲。比方说在高级语言中声明一个类的语言大概是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;class A {}&lt;/code&gt;，这样一段字母人能看懂，机器却不懂，所以就要通过一系列转化把它变成机器能懂的东西 —— 一段内存空间。&lt;/p&gt;

&lt;p&gt;在高级语言中又可以分两个层级 —— 系统编程语言（system programming language）和非系统编程语言。系统编程语言是指那些需要通过直接调用操作系统 API 来实现功能的语言，比如 C、C++、Swift、Rust等。这类语言由于需要直接跟操作系统打交道所以要根据操作系统的不同执行不同的调用，而且这类语言因为离硬件“更近”所以是更加“危险的”，一不小心就可能导致系统崩溃。&lt;/p&gt;

&lt;p&gt;系统编程语言一般可以自己实现自己，而非系统编程语言一般需要通过系统编程语言来实现语法。OC 就是通过 C/C++ 来实现的，用来实现 OC 的代码就在 Runtime 库里面。可以从苹果的开源网站上获取到 Runtime 的源代码 &lt;a href=&quot;https://opensource.apple.com/tarballs/objc4/&quot;&gt;objc4&lt;/a&gt;，GNU 也有一份另外的开源实现。打开 objc4 的代码可以看到里面最主要的文件夹就是 runtime。&lt;/p&gt;

&lt;p&gt;这里可能有一个误区，Runtime 并不能和 OC 的动态特性划等号（Runtime != OC 动态特性），也就是说如果 objc4 的作者想的话，他完全可以把 Objc 实现成一个完全没有动态能力的语言。而 OC 之所以拥有目前的这些动态特性，是由于 Runtime 中用到的一些数据结构提供了动态的能力（也可以不提供）。&lt;/p&gt;

&lt;h1 id=&quot;日常用到的-runtime&quot;&gt;日常用到的 Runtime&lt;/h1&gt;

&lt;p&gt;在日常开发中我们一直都在使用 Runtime 的功能，比如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Objc&quot;&gt;// 根据 instance 对象或者类名获得一个 class 对象
- (Class)class
+ (Class)class
// 判断当前 instance/class 对象的 isa 指向是不是 class/meta-class 对象或者它的子类类型
- (BOOL)isKindOfClass:(Class)cls
+ (BOOL)isKindOfClass:(Class)cls
// 判断当前 instance/class 对象的 isa 指向是不是 class/meta-class 对象类型
- (BOOL)isMemberOfClass:(Class)cls
+ (BOOL)isMemberOfClass:(Class)cls
// 判断对象是否可以接收特定消息
- (BOOL)respondsToSelector:(SEL)sel
+ (BOOL)respondsToSelector:(SEL)sel
// 判断对象是否实现了特定协议中定义的方法
- (BOOL)conformsToProtocol:(Protocol *)protocol
+ (BOOL)conformsToProtocol:(Protocol *)protocol
// 可以根据一个 SEL，得到该方法的 IMP
- (IMP)methodForSelector:(SEL)sel
+ (IMP)methodForSelector:(SEL)sel
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;除了通过 OC 的方法，还可以直接调用 Runtime 库中的 C 函数，比如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;/****** 关联对象相关 ********/
// 添加关联对象
void objc_setAssociatedObject(id object, const void * key, id value, objc_AssociationPolicy policy)
// 获得关联对象
id objc_getAssociatedObject(id object, const void * key)
// 移除指定 object 的所有关联对象
void objc_removeAssociatedObjects(id object)

/***** 属性相关 *********/
// 获取一个属性
objc_property_t class_getProperty(Class cls, const char *name)
// 拷贝属性列表（最后需要调用 free 释放）
objc_property_t *class_copyPropertyList(Class cls, unsigned int *outCount)
// 动态添加属性
BOOL class_addProperty(Class cls, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount)
// 动态替换属性
void class_replaceProperty(Class cls, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount)
// 获取属性的一些信息
const char *property_getName(objc_property_t property)
const char *property_getAttributes(objc_property_t property)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;除此之外还有很多。&lt;/p&gt;

&lt;h1 id=&quot;runtime-使用&quot;&gt;Runtime 使用&lt;/h1&gt;

&lt;p&gt;很多 OC 的著名开源库都用到了 Runtime 提供的功能，比如 MJExtension 字典转模型。&lt;/p&gt;

&lt;p&gt;实现一个简易的字典转模型&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-ObjC&quot;&gt;@interface Person : NSObject &amp;lt;NSSecureCoding&amp;gt;

@property (nonatomic, copy) NSString *name;
@property (nonatomic) int age;

@end

unsigned count;
objc_property_t *properties;
// 获取类的属性个数和属性数组
properties = class_copyPropertyList(Person.class, &amp;amp;count);
NSDictionary *dict = @{@&quot;home&quot;: @&quot;beijing&quot;, @&quot;name&quot;: @&quot;ios开发栈&quot;, @&quot;age&quot;: @3};
Person *p = [[Person alloc] init];
for (int i = 0; i &amp;lt; count; i++) {
    // 获取属性名
    const char *name = property_getName(properties[i]);
    // char * 转换成 NSString *
    NSString *name_s = [NSString stringWithCString:name encoding:NSASCIIStringEncoding];
    // 从字典中取出属性名对应的值
    id value = [dict valueForKey:name_s];
    // 使用 KVC 设置属性值
    [p setValue:value forKey:name_s];
}
NSLog(@&quot;p.name = %@ --- p.age = %d&quot;, p.name, p.age); // p.name = ios开发栈 --- p.age = 3
// 释放 C 对象
free(properties);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;实现自动解档和归档&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-ObjC&quot;&gt;- (void)encodeWithCoder:(NSCoder *)coder
{
    objc_property_t *properties;
    unsigned count;
    properties = class_copyPropertyList(Person.class, &amp;amp;count);
    for (int i = 0; i &amp;lt; count; i++) {
        objc_property_t property = properties[i];
        const char *name = property_getName(property);
        NSString *name_s = [NSString stringWithCString:name encoding:NSUTF8StringEncoding];
        id value = [self valueForKey:name_s];
        // 此处为了简化演示逻辑，就用硬编码了
        if ([name_s isEqualToString:@&quot;age&quot;]) {
            [coder encodeInt:[value intValue] forKey:name_s];
        }
        else {
            [coder encodeObject:value forKey:name_s];
        }
    }
}

- (instancetype)initWithCoder:(NSCoder *)coder
{
    self = [super init];
    if (self) {
        objc_property_t *properties;
        unsigned count;
        properties = class_copyPropertyList(Person.class, &amp;amp;count);
        for (int i = 0; i &amp;lt; count; i++) {
            objc_property_t property = properties[i];
            const char *name = property_getName(property);
            NSString *name_s = [NSString stringWithCString:name encoding:NSUTF8StringEncoding];
            // 此处为了简化演示逻辑，就用硬编码了
            if ([name_s isEqualToString:@&quot;age&quot;]) {
                [self setValue:@([coder decodeIntForKey:name_s]) forKey:name_s];
            }
            else {
                [self setValue:[coder decodeObjectForKey:name_s] forKey:name_s];
            }
        }
    }
    return self;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;除了上面演示的两个功能以外，runtime 能做的事情还有很多，比如常用的给分类添加方法、运行时给类添加方法，以及消息转发等等。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;总结&quot;&gt;总结&lt;/h1&gt;

&lt;p&gt;这篇文章从总体认识一下 Runtime，其实 Runtime 的知识点还有很多，后面我会用多篇文章把主要知识点都覆盖了，希望能够让你对这个知识点融会贯通，学以致用。&lt;/p&gt;

&lt;p&gt;参考链接：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://juejin.cn/post/6844904071480999949&quot;&gt;深入浅出 Runtime（一）：初识&lt;/a&gt;
&lt;a href=&quot;https://www.jianshu.com/p/2b98d77ce7c0&quot;&gt;runtime 自动归档/解档&lt;/a&gt;&lt;/p&gt;</content><author><name></name></author><category term="iOS" /><summary type="html">如果你做过 iOS 开发那你肯定知道 Runtime，作为 Objective-C 语言的基石，Runtime 渗透到 iOS 开发的方方面面。从函数调用到内存管理，再到对象构建都离不开 Runtime 的身影。</summary></entry><entry><title type="html">使用Xcode检测对象内存，处理循环引用</title><link href="http://localhost:4000/xcode/xcode-check-memory-graph/" rel="alternate" type="text/html" title="使用Xcode检测对象内存，处理循环引用" /><published>2022-01-09T04:15:01+08:00</published><updated>2022-01-09T04:15:01+08:00</updated><id>http://localhost:4000/xcode/xcode-check-memory-graph</id><content type="html" xml:base="http://localhost:4000/xcode/xcode-check-memory-graph/">&lt;p&gt;内存管理是高级iOS开发必备知识点，尤其是检测内存泄漏、循环引用更是必须掌握的。当发现内存泄漏时只有能够快速定位才能进行相应的处理，而定位内存问题最便捷的方法就是使用Xcode提供的内存工具。
&lt;!-- more --&gt;
到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../images/memory-graph/cover.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;ios管理内存的方法&quot;&gt;&lt;a href=&quot;#iOS管理内存的方法&quot; title=&quot;iOS管理内存的方法&quot;&gt;&lt;/a&gt;iOS管理内存的方法&lt;/h1&gt;

&lt;p&gt;内存作为计算机的一种资源可供各种应用程序使用，与硬盘不同的是，内存是一种可以非常快速访问的资源，而为了实现这种快速访问就需要用到非常昂贵的材料来制作——与硬盘相比。也因为内存的这种特性决定了它不可能拥有非常大的空间，因此操作系统为了保证每个应用程序都能比较流畅的访问就必须限制单个程序可以使用内存的大小。也就是说，对于一个应用程序来说，内存使用一点就少一点。&lt;/p&gt;

&lt;p&gt;不仅如此，内存中记录了很多应用程序的信息——比如类信息、方法信息等，在应用程序的运行过程中需要根据这些信息来查找或者执行相应的操作，如果某个内存块存储的信息和实际需要的不一致可能会导致非常严重的问题。比如在开发过程中经常遇到了某个类中找不到一个方法就是这种问题。&lt;/p&gt;

&lt;p&gt;所以，在开发过程中我们必须保证只有在需要的时候才去申请内存，并且当不在需要时对应的内存可以及时释放。&lt;/p&gt;

&lt;p&gt;关于内存释放的方案，很多编程语言采用的是&lt;strong&gt;垃圾回收机制&lt;/strong&gt;，据我的理解这是一种被动的回收机制，是依靠某语言的运行时系统每隔一段时间进行一次扫描来发现不再需要的内存然后将其释放。而iOS采用的是主动的回收机制，也就是我们熟知的&lt;strong&gt;引用计数机制&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;按照我的理解，引用计数算是一种以空间换时间的方法。每个内存对象中都有一块用来保存这个对象的引用次数，每增加一个对这个对象的引用这个次数就加一，每减少一个就减一，为0时把这个对象释放掉。&lt;/p&gt;

&lt;p&gt;关于MRC和ARC，它们之间并没有本质的区别，只是工作的负责人改变了，MRC依靠的是iOS开发工程师们来维护对象的引用个数，这显然会因为工程师水平的不同而产生差异，而ARC是把标记引用个数的工作交给了编译器，但是这应该也会带来编译速度的减慢，不过随着编译器性能的提高和电脑硬件的提升，这个问题越来越不明显。&lt;/p&gt;

&lt;h1 id=&quot;ios开发中遇到的内存问题&quot;&gt;&lt;a href=&quot;#iOS开发中遇到的内存问题&quot; title=&quot;iOS开发中遇到的内存问题&quot;&gt;&lt;/a&gt;iOS开发中遇到的内存问题&lt;/h1&gt;

&lt;p&gt;随着引用计数的工作被编译器承担，程序员们在内存上犯错误的难度越来越高。现在最常见的就是循环引用的问题，而之所以编译器无法解决循环引用的问题就是因为它无法确定一个看似会产生循环引用的地方到底会不会产生循环引用，所以最近的编译器都会在可能产生循环引用的地方进行警告，进而期望程序员来手动处理。&lt;/p&gt;

&lt;p&gt;可能会产生内存问题的地方除了循环引用之外，还有全局变量和单例的使用。全局变量可以认为是被当前运行的引用程序所持有，因此只要这个应用程序还没有终止或者该变量的这块内存没有被占用，那么这个变量就会一直存在。而单例其实本质上和全局变量是一样的，不信你可以看看创建单例对象的方法是不是需要一个全局变量。&lt;/p&gt;

&lt;h1 id=&quot;检测内存问题&quot;&gt;&lt;a href=&quot;#检测内存问题&quot; title=&quot;检测内存问题&quot;&gt;&lt;/a&gt;检测内存问题&lt;/h1&gt;

&lt;p&gt;当发现内存问题后，最重要的并不是解决这个问题，而是怎么定位到因为哪里导致的对象没有及时释放。而进行定位最便捷的方式就是使用Xcode的内存布局工具。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../images/memory-graph/icon.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;程序运行起来以后——不管是模拟器还是真机，都可以通过点击这个按钮来查看当前应用程序的内存布局。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../images/memory-graph/gathering-information-about-memory-use-3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这张图的中间部分是某个对象的内存结构树，最右边的是这个对象，左边一层是直接引用这个对象的对象，以此类推。鼠标点击图中的某个对象后该对象的背景色会成蓝色，没有选中的背景色是透明色。&lt;/p&gt;

&lt;p&gt;右边展示的是选中对象的内存监视器，最上面是对象的基本信息包括类名、对象内存地址和内存大小等。中间是继承体系。最下面是这个对象的直接引用树，包括直接引用这个对象的对象，在上层的引用对象，等等。&lt;/p&gt;

&lt;p&gt;默认情况下内存监视器最下面的引用树是不展示的，打开它的方式也很简单。通过Edit Scheme -&amp;gt; Run -&amp;gt; Diagnostics -&amp;gt; Memory Management -&amp;gt; Malloc Stack Logging，默认是没有选中的，点击后选中。然后重新运行程序就可以了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../images/memory-graph/open-backtree.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;举例说明&quot;&gt;&lt;a href=&quot;#举例说明&quot; title=&quot;举例说明&quot;&gt;&lt;/a&gt;举例说明&lt;/h1&gt;

&lt;p&gt;下面用一个简单的例子来说明Xcode的内存分布工具使用方法。&lt;/p&gt;

&lt;p&gt;先创建一个新的ObjC项目，然后在ViewController中创建一个数组，数组中放一个Person对象，这个Person类是中什么都不做。&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#import &quot;ViewController.h&quot;  
#import &quot;Person.h&quot;  
  
@interface ViewController ()  
  
@property (nonatomic) NSMutableArray *mArr;  
  
@end  
  
@implementation ViewController  
  
- (void)viewDidLoad {  
 [super viewDidLoad];  
   
 Person *p = [Person new];  
 self.mArr = @[p].mutableCopy;  
}  
  
@end  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;之后点击下面的内存布局工具，然后在左侧Show the debug navigator中搜索Person。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../images/memory-graph/example.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;从这里明显可以看到p对象是被NSMuatableArray对象引用着，而这个数组又被ViewController引用着。&lt;/p&gt;

&lt;p&gt;到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。&lt;/p&gt;

&lt;h1 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h1&gt;

&lt;p&gt;当发现内存问题后，通过Xcode的内存布局工具可以方便快捷的定位问题出在何处，之后通过对自己项目接口的分析就可以解决掉出现的内存问题了。&lt;/p&gt;</content><author><name></name></author><category term="Xcode" /><summary type="html">内存管理是高级iOS开发必备知识点，尤其是检测内存泄漏、循环引用更是必须掌握的。当发现内存泄漏时只有能够快速定位才能进行相应的处理，而定位内存问题最便捷的方法就是使用Xcode提供的内存工具。 到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。</summary></entry><entry><title type="html">iOS集成Admob的Native广告</title><link href="http://localhost:4000/ios/integrate-Admob-Native/" rel="alternate" type="text/html" title="iOS集成Admob的Native广告" /><published>2022-01-03T02:30:49+08:00</published><updated>2022-01-03T02:30:49+08:00</updated><id>http://localhost:4000/ios/integration-admob-native</id><content type="html" xml:base="http://localhost:4000/ios/integrate-Admob-Native/">&lt;p&gt;Admob广告分为banner、插屏、激励和原生，其中原生广告的集成过程是最复杂的，并且完全按照官方文档或者官方的示例程序是无法成功的，所以有必要把我的集成方法分享给大家。
&lt;!-- more --&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;../../images/admob-native/cover.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;以下内容基于&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Google-Mobile-Ads-SDK&lt;/code&gt;的8.9.0版本。如果不适用于你的版本可以联系我，一块讨论解决。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;admob原生广告&quot;&gt;&lt;a href=&quot;#Admob原生广告&quot; title=&quot;Admob原生广告&quot;&gt;&lt;/a&gt;Admob原生广告&lt;/h1&gt;

&lt;p&gt;原生广告是一种可以自定义广告样式的广告形式，通过集成原生广告可以根据自己App的已有UI来选择广告的样式，使广告能够跟App尽量融合在一起，减少割裂感，进而减少广告对用户的打扰。这种自定义外观的功能是其他形式的广告所不具备的。&lt;/p&gt;

&lt;p&gt;想要集成原生广告总体来说需要进行两步操作：一是自定义广告的界面，二是通过SDK获取广告的数据。&lt;/p&gt;

&lt;h1 id=&quot;获取原生广告数据&quot;&gt;&lt;a href=&quot;#获取原生广告数据&quot; title=&quot;获取原生广告数据&quot;&gt;&lt;/a&gt;获取原生广告数据&lt;/h1&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let nativeAdOptions = GADNativeAdViewAdOptions()  
nativeAdOptions.preferredAdChoicesPosition = .bottomLeftCorner;  
let adLoader = GADAdLoader(adUnitID: &quot;ca-app-pub-3940256099942544/3986624511&quot;, rootViewController: self, adTypes: [.native],  
 options: [nativeAdOptions])  
adLoader.delegate = self  
adLoader.load(GADRequest())  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h1 id=&quot;原生广告加载回调&quot;&gt;&lt;a href=&quot;#原生广告加载回调&quot; title=&quot;原生广告加载回调&quot;&gt;&lt;/a&gt;原生广告加载回调&lt;/h1&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GADAdLoader&lt;/code&gt;对象的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;delegate&lt;/code&gt;需要遵守&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GADNativeAdLoaderDelegate&lt;/code&gt;代理，这个代理遵守了&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GADAdLoaderDelegate&lt;/code&gt;代理，因此这两个代理中的回调都可以用。其中：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GADAdLoaderDelegate&lt;/code&gt;代理中的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;adLoader:didReceiveNativeAd:&lt;/code&gt;表示原生广告加载完成。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GADAdLoaderDelegate&lt;/code&gt;中的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;adLoader:didFailToReceiveAdWithError:&lt;/code&gt;表示广告加载失败。&lt;/p&gt;

&lt;p&gt;在Admob的文档中提到尽量不要在加载失败的回调中重试，不过我认为这里指的是不要立即重试，在实际开发过程中可以根据业务需求采取间隔一定时间后重试。&lt;/p&gt;

&lt;p&gt;在成功的回调中需要把界面和获取到的数据进行绑定，下面有详细的步骤。&lt;/p&gt;

&lt;h1 id=&quot;自定义原生广告样式&quot;&gt;&lt;a href=&quot;#自定义原生广告样式&quot; title=&quot;自定义原生广告样式&quot;&gt;&lt;/a&gt;自定义原生广告样式&lt;/h1&gt;

&lt;p&gt;根据Admob文档的描述，可以通过xib的形式来自定义原生广告样式。可以通过查看&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GADNativeAdView&lt;/code&gt;类确定原生广告支持的组件类型和个数，里面大多数都是用的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UIView&lt;/code&gt;不过在实际过程中需要区分&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UILabel&lt;/code&gt;/&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UIImageView&lt;/code&gt;或者&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UIButton&lt;/code&gt;。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;实际类型&lt;/th&gt;
      &lt;th&gt;字段名&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;UILabel&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;headlineView&lt;/code&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bodyView&lt;/code&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;storeView&lt;/code&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;priceView&lt;/code&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;advertiserView&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;UIButton&lt;/td&gt;
      &lt;td&gt;callToActionView&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;UIImageView&lt;/td&gt;
      &lt;td&gt;iconView imageView starRatingView&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;GADMediaView&lt;/td&gt;
      &lt;td&gt;mediaView&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;根据UI需求完成xib的布局：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../images/admob-native/xib.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;并把这个xib文件命名为：AdmobNative.xib。&lt;/p&gt;

&lt;p&gt;截止到这里你会发现我们并没有创建类文件，那是因为Admob的SDK里已经有这样的类文件了，我们需要做的就是把这个xib文件和已经存在的类文件关联起来，也就是“连上线”。&lt;/p&gt;

&lt;h1 id=&quot;xib文件关联类&quot;&gt;&lt;a href=&quot;#xib文件关联类&quot; title=&quot;xib文件关联类&quot;&gt;&lt;/a&gt;xib文件关联类&lt;/h1&gt;

&lt;p&gt;如果按照官方文档的描述，可以直接把刚刚创建的xib文件和Admob库里面&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GADNativeAd.h&lt;/code&gt;文件中的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GADNativeAdView&lt;/code&gt;类进行关联，而这个类中属性也都是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IBOutlet&lt;/code&gt;的，但是当你这么做的时候发现并不能连上线，无法进行关联。&lt;/p&gt;

&lt;p&gt;之所以出现这种情况是因为官方文档过时了，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Google-Mobile-Ads-SDK&lt;/code&gt;库在之前是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;framework&lt;/code&gt;的形式，而现在改成了&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;xcframework&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;所以要想进行连线就得另辟蹊径了。&lt;/p&gt;

&lt;p&gt;我们都知道，OC的.h和.m文件类似C语言的.h和.m，具体来说就是.h文件只是接口声明，它的作用就是让编译器不报错，而在实际运行时还是要看.m文件中是否确实有该方法或者变量。&lt;/p&gt;

&lt;p&gt;作为仅有声明作用的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.h&lt;/code&gt;文件，我们是可以随便创建的，只要声明的内容在.m文件里有实现就可以了。那么我们就可以&lt;strong&gt;把&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Google-Mobile-Ads-SDK&lt;/code&gt;中&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GADNativeAd.h&lt;/code&gt;文件拷贝一份到自己的项目里&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;把&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GADNativeAd.h&lt;/code&gt;文件原封不动的拷贝到自己的项目中后，就可以随心所欲的进行连线了。&lt;/p&gt;

&lt;p&gt;把xib中的界面和类文件里的属性关联以后，就可以把请求到的广告内容显示到界面上了。&lt;/p&gt;

&lt;h1 id=&quot;显示获取到的广告数据&quot;&gt;&lt;a href=&quot;#显示获取到的广告数据&quot; title=&quot;显示获取到的广告数据&quot;&gt;&lt;/a&gt;显示获取到的广告数据&lt;/h1&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Mark: - GADNativeAdLoaderDelegate  
func adLoader(_ adLoader: GADAdLoader, didReceive nativeAd: GADNativeAd) {  
 print(&quot;Received native ad: (nativeAd)&quot;)  
 refreshAdButton.isEnabled = true  
 // Create and place ad in view hierarchy.  
 let nibView = Bundle.main.loadNibNamed(&quot;NativeAdView&quot;, owner: nil, options: nil)?.first  
 guard let nativeAdView = nibView as? GADNativeAdView else {  
 return  
 }  
 setAdView(nativeAdView)  
  
 // Set ourselves as the native ad delegate to be notified of native ad events.  
 nativeAd.delegate = self  
  
 // Populate the native ad view with the native ad assets.  
 // The headline and mediaContent are guaranteed to be present in every native ad.  
 (nativeAdView.headlineView as? UILabel)?.text = nativeAd.headline  
 nativeAdView.mediaView?.mediaContent = nativeAd.mediaContent  
  
 // This app uses a fixed width for the GADMediaView and changes its height to match the aspect  
 // ratio of the media it displays.  
 if let mediaView = nativeAdView.mediaView, nativeAd.mediaContent.aspectRatio &amp;gt; 0 {  
 let heightConstraint = NSLayoutConstraint(  
 item: mediaView,  
 attribute: .height,  
 relatedBy: .equal,  
 toItem: mediaView,  
 attribute: .width,  
 multiplier: CGFloat(1 / nativeAd.mediaContent.aspectRatio),  
 constant: 0)  
 heightConstraint.isActive = true  
 }  
  
 // These assets are not guaranteed to be present. Check that they are before  
 // showing or hiding them.  
 (nativeAdView.bodyView as? UILabel)?.text = nativeAd.body  
 nativeAdView.bodyView?.isHidden = nativeAd.body == nil  
  
 (nativeAdView.callToActionView as? UIButton)?.setTitle(nativeAd.callToAction, for: .normal)  
 nativeAdView.callToActionView?.isHidden = nativeAd.callToAction == nil  
  
 (nativeAdView.iconView as? UIImageView)?.image = nativeAd.icon?.image  
 nativeAdView.iconView?.isHidden = nativeAd.icon == nil  
  
 (nativeAdView.starRatingView as? UIImageView)?.image = imageOfStars(  
 fromStarRating: nativeAd.starRating)  
 nativeAdView.starRatingView?.isHidden = nativeAd.starRating == nil  
  
 (nativeAdView.storeView as? UILabel)?.text = nativeAd.store  
 nativeAdView.storeView?.isHidden = nativeAd.store == nil  
  
 (nativeAdView.priceView as? UILabel)?.text = nativeAd.price  
 nativeAdView.priceView?.isHidden = nativeAd.price == nil  
  
 (nativeAdView.advertiserView as? UILabel)?.text = nativeAd.advertiser  
 nativeAdView.advertiserView?.isHidden = nativeAd.advertiser == nil  
  
 // In order for the SDK to process touch events properly, user interaction should be disabled.  
 nativeAdView.callToActionView?.isUserInteractionEnabled = false  
  
 // Associate the native ad view with the native ad object. This is  
 // required to make the ad clickable.  
 // Note: this should always be done after populating the ad views.  
 nativeAdView.nativeAd = nativeAd  
}  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;其中有两点需要注意：一是通过设置&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nativeAdView.callToActionView?.isUserInteractionEnabled = false&lt;/code&gt;来使用户可以通过点击按钮跳转到App Store或者广告主的网站，二是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nativeAdView.nativeAd = nativeAd&lt;/code&gt;来把数据和界面进行关联，只有这样广告的元素才会响应用户点击执行跳转。&lt;/p&gt;

&lt;h1 id=&quot;广告视图事件处理&quot;&gt;&lt;a href=&quot;#广告视图事件处理&quot; title=&quot;广告视图事件处理&quot;&gt;&lt;/a&gt;广告视图事件处理&lt;/h1&gt;

&lt;p&gt;上面的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nativeAd.delegate = self&lt;/code&gt;可以让当前类获取到广告视图的事件回调，比如点击、跳转、展示等，具体可以查看&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GADNativeAdDelegate&lt;/code&gt;。其中有一点需要注意的是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nativeAdDidRecordImpression:&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nativeAdDidRecordClick:&lt;/code&gt;回调仅对Admob自家的广告有效，也就是说如果通过Admob聚合其他广告商的原生广告是无法获取到这两个回调事件的。&lt;/p&gt;

&lt;p&gt;至此，集成Admob原生广告的工作就结束了。👍&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h1&gt;

&lt;p&gt;通过这篇文章我们对Admob原生广告的集成过程有了一个全面的了解，并且对一些官方文档的过时内容也进行了更正处理，相信你现在可以处理接入Admob原生广告的需求了，那么动手开始吧。&lt;/p&gt;</content><author><name></name></author><category term="广告集成" /><summary type="html">Admob广告分为banner、插屏、激励和原生，其中原生广告的集成过程是最复杂的，并且完全按照官方文档或者官方的示例程序是无法成功的，所以有必要把我的集成方法分享给大家。 到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。</summary></entry><entry><title type="html">汇编分析函数调用</title><link href="http://localhost:4000/cs/analyse-function-call-using-assembly/" rel="alternate" type="text/html" title="汇编分析函数调用" /><published>2021-12-19T01:33:37+08:00</published><updated>2021-12-19T01:33:37+08:00</updated><id>http://localhost:4000/cs/assembly-function-call</id><content type="html" xml:base="http://localhost:4000/cs/analyse-function-call-using-assembly/">&lt;p&gt;通过对汇编的分析可以了解程序的执行本质，对分析问题有很大的帮助，尤其在无法阅读源码的情况下更加有用。最近我刚阅读了《深入理解计算机系统（CSAPP）》的第三章，这一章主要讲解汇编的知识。为了对自己的学习有一个总结，并且给对汇编不甚了解的同学一点启发，所以有了这篇关于汇编的文章。&lt;/p&gt;

&lt;p&gt;通过分析函数调用过程可以了解整个汇编的全貌，并且对实际的编程工作也有最大的作用。所以，让我们从一个简单的递归调用函数进入汇编的世界吧。
&lt;!-- more --&gt;
通过对汇编的分析可以了解程序的执行本质，对分析问题有很大的帮助，尤其在无法阅读源码的情况下更加有用。最近我刚阅读了《深入理解计算机系统（CSAPP）》的第三章，这一章主要讲解汇编的知识。为了对自己的学习有一个总结，并且给对汇编不甚了解的同学一点启发，所以有了这篇关于汇编的文章。&lt;/p&gt;

&lt;p&gt;通过分析函数调用过程可以了解整个汇编的全貌，并且对实际的编程工作也有最大的作用。所以，让我们从一个简单的递归调用函数进入汇编的世界吧。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;../../images/first/assemb-recurse-call.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;c语言表示&quot;&gt;&lt;a href=&quot;#C语言表示&quot; title=&quot;C语言表示&quot;&gt;&lt;/a&gt;C语言表示&lt;/h1&gt;

&lt;p&gt;用C语言计算0到20的整数之和：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;  
  
int add(int start, int max) {  
 if (start == max) {  
 return max;  
 }  
 return start + add(start + 1, max);  
}  
  
int main(int argc, char const *argv[])  
{  
 int result = add(0, 20);  
 printf(&quot;result = %d\n&quot;, result);  
 return 0;  
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;add&lt;/code&gt;是一个递归函数，用来计算&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;start&lt;/code&gt;到&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;max&lt;/code&gt;的整数之和。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;main&lt;/code&gt;函数中调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;add&lt;/code&gt;函数计算0到20的和，并输出到控制台。&lt;/p&gt;

&lt;p&gt;把上面的代码保存到文件&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;recursion.c&lt;/code&gt;文件。&lt;/p&gt;

&lt;h1 id=&quot;生成汇编&quot;&gt;&lt;a href=&quot;#生成汇编&quot; title=&quot;生成汇编&quot;&gt;&lt;/a&gt;生成汇编&lt;/h1&gt;

&lt;p&gt;通过gcc生成汇编:&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;gcc -S recursion.c  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;执行上面命令，获取到的汇编如下：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;_add:                                   ## @add  
pushq%rbp  
movq%rsp, %rbp  
subq$16, %rsp  
movl%edi, -8(%rbp)  
movl%esi, -12(%rbp)  
movl-8(%rbp), %eax  
cmpl-12(%rbp), %eax  
jneLBB0_2  
movl-12(%rbp), %eax  
movl%eax, -4(%rbp)  
jmpLBB0_3  
LBB0_2:  
movl-8(%rbp), %eax  
movl%eax, -16(%rbp)                 ## 4-byte Spill  
movl-8(%rbp), %edi  
addl$1, %edi  
movl-12(%rbp), %esi  
callq_add  
movl%eax, %ecx  
movl-16(%rbp), %eax                 ## 4-byte Reload  
addl%ecx, %eax  
movl%eax, -4(%rbp)  
LBB0_3:  
movl-4(%rbp), %eax  
addq$16, %rsp  
popq%rbp  
retq  
_main:                                  ## @main  
pushq%rbp  
movq%rsp, %rbp  
subq$32, %rsp  
movl%edi, %eax  
xorl%edi, %edi  
movl$0, -4(%rbp)  
movl%eax, -8(%rbp)  
movq%rsi, -16(%rbp)  
movl$20, %esi  
callq_add  
movl%eax, -20(%rbp)  
movl-20(%rbp), %esi  
leaqL_.str(%rip), %rdi  
movb$0, %al  
callq_printf  
xorl%eax, %eax  
addq$32, %rsp  
popq%rbp  
retq
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上面的内容是精简过的，去掉了一些说明性的内容，对实际的效果没有任何影响。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_add&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_main&lt;/code&gt;标签表示函数段开始，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LBB0_2&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LBB0_3&lt;/code&gt;是汇编语言生成的标签，用来进行跳转；剩下的都是汇编指令。&lt;/p&gt;

&lt;h1 id=&quot;main函数&quot;&gt;&lt;a href=&quot;#main函数&quot; title=&quot;main函数&quot;&gt;&lt;/a&gt;main函数&lt;/h1&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;main&lt;/code&gt;函数我们只看和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;add&lt;/code&gt;函数有关的部分：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;_main:  
...  
xorl%edi, %edi  
movl$0, -4(%rbp)  
movl$20, %esi  
callq_add  
...  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;xorl %edi, %edi&lt;/code&gt;用来把edi寄存器的值设为0，其中&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;xor&lt;/code&gt;表示异或操作，而两个相同的数异或的值等于0，而&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;xorl&lt;/code&gt;中的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;l&lt;/code&gt;表示整数。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;movl $0, -4(%rbp)&lt;/code&gt;——rbp-4表示一个内存地址，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;movl&lt;/code&gt;表示把整数0移动到内存rbp-4。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;movl $20, %esi&lt;/code&gt;——把20放到esi寄存器中。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;call&lt;/code&gt;表示函数调用，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_add&lt;/code&gt;是C语言中add函数的汇编标签。&lt;/p&gt;

&lt;h1 id=&quot;add函数&quot;&gt;&lt;a href=&quot;#add函数&quot; title=&quot;add函数&quot;&gt;&lt;/a&gt;add函数&lt;/h1&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;movl%edi, -8(%rbp)  
movl%esi, -12(%rbp)  
movl-8(%rbp), %eax  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;通过上面main函数的分析得知edi寄存器中保存的整数0，esi寄存器中放的是整数20。而通过1、3行&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;movl&lt;/code&gt;操作后，把0放到了eax寄存器中；第2行中把20放到了内存地址rbp-12。&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cmpl-12(%rbp), %eax  
jneLBB0_2  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cmp&lt;/code&gt;是英文单词compare的缩写，也就是比较的意思。因此第1行是比较内存地址rbp-12和寄存器eax中的值。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;j&lt;/code&gt;是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;jump&lt;/code&gt;的缩写，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ne&lt;/code&gt;是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;not equal&lt;/code&gt;的缩写，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;jne&lt;/code&gt;表示如果不想等就跳转，而跳转的目的是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LBB0_2&lt;/code&gt;标签。&lt;/p&gt;

&lt;p&gt;而在整个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;add&lt;/code&gt;函数的递归过程中，之前几次都是不想等的，那我们继续看不相等的时候跳转到&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LBB0_2&lt;/code&gt;段。&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;movl-8(%rbp), %eax  
movl%eax, -16(%rbp)                 ## 4-byte Spill  
movl-8(%rbp), %edi  
addl$1, %edi  
movl-12(%rbp), %esi  
callq_add  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;第6行的又调用了&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;add&lt;/code&gt;函数，而第4行、第5行是准备函数参数。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;addl $1, %edi&lt;/code&gt;——edi寄存器中的值加1后放回edi寄存器。&lt;/p&gt;

&lt;p&gt;从上面的分析可以看出edi和esi两个寄存器用做参数传递。&lt;/p&gt;

&lt;p&gt;整个递归过程是通过使用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;jne&lt;/code&gt;命令比较两个整数的大小，如果不想等就跳转到&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LBB0_2&lt;/code&gt;标签，而在这个标签中又重新回到了&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;add&lt;/code&gt;函数最开始的地方。直到edi和esi中保存的两个整数相等为止。&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;movl-12(%rbp), %eax  
movl%eax, -4(%rbp)  
jmpLBB0_3  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;esi和edi的值相等时，取出rbp-12内存地址中的值放入eax寄存器，再把eax寄存器的值放入rbp-4内存中。之后跳转到&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LBB0_3&lt;/code&gt;标签处。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;movl-4(%rbp), %eax  
addq$16, %rsp  
popq%rbp  
retq  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;第2行和第3行是还原函数调用栈——为了控制文章篇幅，省略这个知识点，有兴趣的话可以留言，以后再讲。&lt;/p&gt;

&lt;p&gt;第1行是把rbp-4内存中保存的内容放入eax，也就是把函数的返回值放入eax。——eax寄存器通常用来保存函数返回值。&lt;/p&gt;

&lt;p&gt;上面提到，edi寄存器存放start变量值，esi存放max变量值。这样就很容易可以得到，内存地址ebp-8和ebp-16中存放的是start变量，其中ebp-16只用来保存最新的start值；ebp-12存放的是max变量。&lt;/p&gt;

&lt;p&gt;这里有一个地方需要注意：ebp中存放的内存地址在整个递归过程中是不断变化的。递归过程实际是在不断的进行函数调用，每次进行函数调用都会产生新的调用栈，那就会更新ebp中存放的地址值。随着ebp中存放的地址值改变，每一个新的start值都被放到了不同的内存地址中。&lt;/p&gt;

&lt;p&gt;当结束条件（start == max）得到满足，递归结束。此时start的值等于max，调用跳转到LBB0_3中遇到了&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ret&lt;/code&gt;命令，当前的调用栈被返回，也就是继续执行&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;callq _add&lt;/code&gt;下面的汇编代码。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;movl%eax, %ecx  
movl-16(%rbp), %eax                 ## 4-byte Reload  
addl%ecx, %eax  
movl%eax, -4(%rbp)  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这里进行一些内容的交换之外，主要把最新的start值加上之前得到的start+max的和。而在这里由于没有跳转命令，所以会继续执行&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LBB0_3&lt;/code&gt;中的内容，进而不断的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ret&lt;/code&gt;出栈。&lt;/p&gt;

&lt;p&gt;最终，把所有递归调用栈都ret完以后，最后一次的LBB0_3中的ret会返回到main函数中对add函数的调用处。&lt;/p&gt;

&lt;p&gt;整个递归调用完成。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h1&gt;

&lt;p&gt;这篇文章通过对C语言中一个简单的递归调用过程的汇编代码进行分析，了解到递归调用的本质是jmp跳转命令和函数调用栈的结合使用。由于篇幅有限对函数栈、内存以及寄存器进行过多的分析，有兴趣的小伙伴可以直接去看《深入理解计算机系统》第三章，如果有兴趣可以留言，以后继续分析这方面的内容。&lt;/p&gt;</content><author><name></name></author><category term="计算机基础" /><summary type="html">通过对汇编的分析可以了解程序的执行本质，对分析问题有很大的帮助，尤其在无法阅读源码的情况下更加有用。最近我刚阅读了《深入理解计算机系统（CSAPP）》的第三章，这一章主要讲解汇编的知识。为了对自己的学习有一个总结，并且给对汇编不甚了解的同学一点启发，所以有了这篇关于汇编的文章。</summary></entry><entry><title type="html">iOS事件传递链，巧用nextResponder跨层传递</title><link href="http://localhost:4000/ios/iOS-responder-chain/" rel="alternate" type="text/html" title="iOS事件传递链，巧用nextResponder跨层传递" /><published>2021-11-21T05:00:50+08:00</published><updated>2021-11-21T05:00:50+08:00</updated><id>http://localhost:4000/ios/responder-chain</id><content type="html" xml:base="http://localhost:4000/ios/iOS-responder-chain/">&lt;p&gt;在开发过程中你肯定遇到过这种场景：控制器的View中包含一个自定义视图A，A里又有包含button的自定义视图B，当用户点击button需要跳转到另一个控制器。此时跳转的逻辑当然应该在控制器里，那么要想把这个button的点击事件传递到控制器里要可以通过代理或者在控制器里&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;self.view.A.B.button addTarget&lt;/code&gt;，除此之外还可以利用事件传递链来更和谐的处理。&lt;/p&gt;

&lt;p&gt;本文我们主要包括对事件传递链理论的理解和利用传递链处理实际的业务需求。
&lt;!-- more --&gt;
在开发过程中你肯定遇到过这种场景：控制器的View中包含一个自定义视图A，A里又有包含button的自定义视图B，当用户点击button需要跳转到另一个控制器。此时跳转的逻辑当然应该在控制器里，那么要想把这个button的点击事件传递到控制器里要可以通过代理或者在控制器里&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;self.view.A.B.button addTarget&lt;/code&gt;，除此之外还可以利用事件传递链来更和谐的处理。&lt;/p&gt;

&lt;p&gt;本文我们主要包括对事件传递链理论的理解和利用传递链处理实际的业务需求。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;../../images/responder-chain/cover.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;ios的事件响应链&quot;&gt;&lt;a href=&quot;#iOS的事件响应链&quot; title=&quot;iOS的事件响应链&quot;&gt;&lt;/a&gt;iOS的事件响应链&lt;/h1&gt;

&lt;p&gt;首先要说明，这里说的_不是传递链_，传递链是事件的传递过程，而这里说的响应链是指事件在找到最合适的响应者以后的响应过程。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../images/responder-chain/AView.png&quot; alt=&quot;项目场景&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在这样一个例子中，当用户点击了最内层的Button以后要让最外层的ViewController跳转到一个新的VC，我们有这样几种方法：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;ViewB中添加&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;delegate&lt;/code&gt;属性，并让ViewA作为它的delegate，同样VC作为viewA的delegate。这种方法最为清晰，但是如果层数继续增加，这个代理层数就会很深，也就需要写很多的胶水代码。&lt;/li&gt;
  &lt;li&gt;在VC中通过&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;self.view.viewA.viewB.button&lt;/code&gt;可以得到button的引用，之后可以直接通过&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;button addTarget:self xxx&lt;/code&gt;直接给button添加事件。这样做省去了添加代理，但是必须每一层都把view暴露在头文件里。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;除此之外还可以利用事件响应链的奇技淫巧来处理。在上面的场景中，点击button后的响应链是：&lt;em&gt;button -&amp;gt; viewB -&amp;gt; viewA -&amp;gt; vc.view -&amp;gt; vc&lt;/em&gt;，概括来说就是：事件响应链是由内向外，直到最外层的view，之后传递给控制器，最终传递给window。&lt;/p&gt;

&lt;p&gt;其中有两点很重要&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UIResponder&lt;/code&gt;及其子类可以作为响应链的一环，包括UIView及其子类和UIControl等。&lt;/li&gt;
  &lt;li&gt;通过&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nextResponder&lt;/code&gt;可以获取到下一环的响应者。&lt;/li&gt;
  &lt;li&gt;事件会在触发后沿着继承体系寻找能够处理它的类，直到找到。&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;嵌套多层视图事件传递&quot;&gt;&lt;a href=&quot;#嵌套多层视图事件传递&quot; title=&quot;嵌套多层视图事件传递&quot;&gt;&lt;/a&gt;嵌套多层视图事件传递&lt;/h1&gt;

&lt;p&gt;有了上面的理论基础，让我们来看一下类似场景使用响应链的处理方法。&lt;/p&gt;

&lt;p&gt;首先在viewB中的代码和控制器中的代码大概是这样：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// ViewB 
[self.button addTarget:self action:@selector(showDetail) forControlEvents:UIControlEventsTouchupInside)];  
  
// 控制器
- (void)showDetail {  
  
}  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;现在问题是怎么才能让控制器响应到ViewB中的showDetail方法。&lt;/p&gt;

&lt;p&gt;结合上面的理论知识，我们可以知道当在ViewB中没有处理&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;showDetail&lt;/code&gt;事件时，这个事件会沿着继承链向上寻找到ViewB的父类——UIView，而UIView中肯定没有showDetail的实现，那就继续到UIView的父类&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UIResponder&lt;/code&gt;中寻找，很明显UIResponder中也没有这个方法的实现。&lt;/p&gt;

&lt;p&gt;不过我们可以给UIResponder添加一个包含showDetail方法的分类来实现这个方法。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// UIResponder+Chain.m    
- (void)showDetail {  
  
}  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;添加这样一个分类以后，点击ViewB中的button就不会崩溃了。不过这样仍然无法让VC中的事件得到响应。&lt;/p&gt;

&lt;p&gt;在这个基础上，我们知道通过&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nextResponder&lt;/code&gt;可以获取到下一个响应者。那么给上面的空方法添加这样一个实现：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// UIResponder+Chain.m  
  
- (void)showDetail {  
 [self.nextResponder showDetail];  
}  

通过添加`[self.nextResponder showDetail];`，整个过程成了这样：

1.  ViewB中的按钮事件通过继承链被UIResponder响应了（也就是说ViewB响应了事件），
2.  viewB的nextResponder是viewA，虽然viewA中没有实现但是通过继承链它仍然可以响应，
3.  控制的视图作为viewA的父视图——viewA.nextResponder——也通过继承链处理这个事件，
4.  控制器视图的nextReponsder就是控制器本身，而`[self.view.nextResponder showDetail]`就调用到了在控制器中实现的`showDetail`方法。

经过这样的过程，实现了点击viewB中的按钮后控制器中的方法被调用了。

到这里，恭喜你掌握了这个实际开发中的利器。🎉🎉🎉

# [](#让视图层级中的多个父视图响应同一个事件 &quot;让视图层级中的多个父视图响应同一个事件&quot;)让视图层级中的多个父视图响应同一个事件

在上面的例子中，当用户点击了viewB中的button之后，想要让viewA和控制器都能够获取到这个事件也很容易。

只需要在viewA和控制器中同时实现`showDetail`方法，不过由于viewA并不是最终的一环，需要在方法中这样做：

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;// viewA
#import “UIResponder+chain.h”&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;(void)showDetail {&lt;br /&gt;
 [self.nextResponder showDetail];
 &amp;lt;#viewA自定义处理#&amp;gt;&lt;br /&gt;
}
```
    &lt;h1 id=&quot;完善和注意点&quot;&gt;&lt;a href=&quot;#完善和注意点&quot; title=&quot;完善和注意点&quot;&gt;&lt;/a&gt;完善和注意点&lt;/h1&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;消除undeclared-selector警告&quot;&gt;&lt;a href=&quot;#消除Undeclared-selector警告&quot; title=&quot;消除Undeclared selector警告&quot;&gt;&lt;/a&gt;消除&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Undeclared selector&lt;/code&gt;警告&lt;/h2&gt;

&lt;p&gt;在viewB中给button添加了方法，但是并没有对应的实现，这时候Xcode会有&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Undeclared selector&lt;/code&gt;警告。要处理这个警告有两个方法：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// ViewB
  
// 处理Undeclared selector方法一  
#import &quot;UIResponder+chain.h&quot;  
- (void)showDetail {
 [self.nextResponder showDetail];
}
 
// 处理Undeclared selector方法二  
#pragma clang diagnostic push  
#pragma clang diagnostic ignored &quot;-Wundeclared-selector&quot;  
 [self.button addTarget:self action:@selector(showDetail) forControlEvents:UIControlEventsTouchupInside)];  
#pragma clang diagnostic pop  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h2 id=&quot;xib&quot;&gt;&lt;a href=&quot;#xib&quot; title=&quot;xib&quot;&gt;&lt;/a&gt;xib&lt;/h2&gt;

&lt;p&gt;如果viewB是通过xib创建的，那么可以先把线连出来，之后把.m里面的方法删除&lt;/p&gt;

&lt;h2 id=&quot;小心找不到响应者&quot;&gt;&lt;a href=&quot;#小心找不到响应者&quot; title=&quot;小心找不到响应者&quot;&gt;&lt;/a&gt;小心找不到响应者&lt;/h2&gt;

&lt;p&gt;如果你一不小心在上面控制器的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;showDetail&lt;/code&gt;方法中又添加了&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[self.nextResponder showDetail]&lt;/code&gt;，那程序就要crash了，为了防止这种情况，最好利用事件转发的特性进行防护——永远不要相信任何代码，包括自己写的。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h1&gt;

&lt;p&gt;这篇文章我们掌握了通过利用事件响应链来处理多层嵌套的视图传递事件的方法，虽然这种方式看起来挺高端，但是正如上面说的一样，它的风险是很高的，所以如果必要不要使用这种奇技淫巧。&lt;/p&gt;</content><author><name></name></author><category term="UI" /><summary type="html">在开发过程中你肯定遇到过这种场景：控制器的View中包含一个自定义视图A，A里又有包含button的自定义视图B，当用户点击button需要跳转到另一个控制器。此时跳转的逻辑当然应该在控制器里，那么要想把这个button的点击事件传递到控制器里要可以通过代理或者在控制器里self.view.A.B.button addTarget，除此之外还可以利用事件传递链来更和谐的处理。</summary></entry></feed>